{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Jubilee Powder Documentation","text":"<p>Welcome to the Jubilee Powder documentation! This system provides automated powder dispensing and handling using the Jubilee Motion Platform for precision laboratory tasks.</p>"},{"location":"#what-is-jubilee-powder","title":"What is Jubilee Powder?","text":"<p>Jubilee Powder is a Python-based system that enables programmatic control of the Jubilee Motion Platform for automated powder dispensing operations. It provides high-level abstractions for complex operations like precision powder dispensing, weighing, and material handling.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#for-users","title":"For Users","text":"<p>If you're looking to use the Jubilee system for your laboratory work:</p> <ul> <li>Start here: Quick Start Guide</li> <li>Learn concepts: Architecture Overview</li> <li>Follow recipes: How-To Guides</li> <li>Use the UI: Web Interface Guide</li> </ul>"},{"location":"#for-developers","title":"For Developers","text":"<p>If you're looking to extend or modify the system:</p> <ul> <li>Core API: JubileeManager Reference</li> <li>State Machine: MotionPlatformStateMachine Reference</li> <li>All APIs: Complete API Reference</li> </ul>"},{"location":"#whats-important","title":"What's Important?","text":""},{"location":"#primary-interface-jubileemanager","title":"Primary Interface: JubileeManager","text":"<p>The <code>JubileeManager</code> class is your main entry point. It provides:</p> <ul> <li>\u2705 Safe, validated movements through an internal state machine</li> <li>\u2705 High-level operations (dispense, weigh, move)</li> <li>\u2705 Connection management for all hardware components</li> <li>\u2705 Error handling and safety checks</li> </ul> <p>You should interact with <code>JubileeManager</code> for almost everything.</p>"},{"location":"#advanced-control-motionplatformstatemachine","title":"Advanced Control: MotionPlatformStateMachine","text":"<p>The <code>MotionPlatformStateMachine</code> provides granular control when needed:</p> <ul> <li>\u26a0\ufe0f Direct state machine access for complex sequences</li> <li>\u26a0\ufe0f Lower-level movement primitives</li> <li>\u26a0\ufe0f Custom validation logic</li> </ul> <p>Only use this if JubileeManager doesn't provide what you need.</p>"},{"location":"#simple-example","title":"Simple Example","text":"<p>Here's a minimal example of using JubileeManager to perform a powder dispense operation:</p> <pre><code>from src.JubileeManager import JubileeManager\n\n# Create and connect to the powder dispensing system\nmanager = JubileeManager(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10\n)\n\n# Connect to hardware\nif manager.connect(\n    machine_address=\"192.168.1.100\",\n    scale_port=\"/dev/ttyUSB0\"\n):\n    print(\"Connected successfully!\")\n\n    # Perform a dispense operation\n    success = manager.dispense_to_well(\n        well_id=\"A1\",\n        target_weight=50.0  # grams\n    )\n\n    if success:\n        print(\"Dispense complete!\")\n\n    # Clean up\n    manager.disconnect()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Hardware Integration: Control Jubilee motion platform, scales, and dispensers</li> <li>Safety Validation: All movements validated through state machine</li> <li>Flexible Configuration: JSON-based configuration system</li> <li>Web Interface: Browser-based control and monitoring</li> <li>Type Safety: Full type hints throughout the codebase</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<pre><code>graph TD\n    A[User Code] --&gt; B[JubileeManager]\n    B --&gt; C[MotionPlatformStateMachine]\n    C --&gt; D[Jubilee Machine]\n    C --&gt; E[Scale]\n    C --&gt; F[PistonDispenser]\n    B --&gt; G[Manipulator]\n    G --&gt; C</code></pre> <p>The system uses a layered architecture where:</p> <ol> <li>User Code interacts with <code>JubileeManager</code></li> <li>JubileeManager coordinates high-level operations</li> <li>MotionPlatformStateMachine validates and executes movements</li> <li>Hardware Components (Jubilee, Scale, Dispensers) perform physical actions</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>New to the system? Start with the Quick Start Guide</li> <li>Ready to use it? Check out the How-To Guides</li> <li>Need API details? Browse the API Reference</li> <li>Want to understand the design? Read the Architecture Guide</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<p>If you encounter issues or have questions:</p> <ol> <li>Check the Glossary for terminology</li> <li>Review the How-To Guides for common tasks</li> <li>Consult the API Reference for detailed function documentation</li> </ol>"},{"location":"api/config-loader/","title":"ConfigLoader API Reference","text":"<p>The <code>ConfigLoader</code> module provides centralized access to system configuration from JSON files.</p>"},{"location":"api/config-loader/#overview","title":"Overview","text":"<p>ConfigLoader:</p> <ul> <li>Loads configuration from JSON files</li> <li>Provides type-safe access to configuration values</li> <li>Handles default values</li> <li>Validates configuration data</li> </ul>"},{"location":"api/config-loader/#module-reference","title":"Module Reference","text":""},{"location":"api/config-loader/#src.ConfigLoader","title":"ConfigLoader","text":"<p>Configuration loader for Jubilee automation system. Loads system-wide configuration parameters from JSON files.</p>"},{"location":"api/config-loader/#src.ConfigLoader-attributes","title":"Attributes","text":""},{"location":"api/config-loader/#src.ConfigLoader.config","title":"config  <code>module-attribute</code>","text":"<pre><code>config = ConfigLoader()\n</code></pre>"},{"location":"api/config-loader/#src.ConfigLoader-classes","title":"Classes","text":""},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader","title":"ConfigLoader","text":"<pre><code>ConfigLoader()\n</code></pre> <p>Loads and manages system configuration</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader-functions","title":"Functions","text":""},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get","title":"get","text":"<pre><code>get(key_path, default=None)\n</code></pre> <p>Get configuration value using dot notation (e.g., 'safety.safe_z')</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get_safe_z","title":"get_safe_z","text":"<pre><code>get_safe_z()\n</code></pre> <p>Get safe Z height</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get_safe_z_offset","title":"get_safe_z_offset","text":"<pre><code>get_safe_z_offset()\n</code></pre> <p>Get safe Z offset</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get_max_weight_per_well","title":"get_max_weight_per_well","text":"<pre><code>get_max_weight_per_well()\n</code></pre> <p>Get maximum weight per well</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get_weight_tolerance","title":"get_weight_tolerance","text":"<pre><code>get_weight_tolerance()\n</code></pre> <p>Get weight tolerance</p>"},{"location":"api/config-loader/#src.ConfigLoader.ConfigLoader.get_duet_ip","title":"get_duet_ip","text":"<pre><code>get_duet_ip()\n</code></pre> <p>Get DUET IP address</p>"},{"location":"api/config-loader/#usage-examples","title":"Usage Examples","text":""},{"location":"api/config-loader/#basic-configuration-access","title":"Basic Configuration Access","text":"<pre><code>from src.ConfigLoader import config\n\n# Get Duet IP address\nip = config.get_duet_ip()\nprint(f\"Jubilee IP: {ip}\")\n\n# Get scale port\nport = config.get_scale_port()\nprint(f\"Scale port: {port}\")\n\n# Get system configuration\nsys_config = config.get_system_config()\nprint(f\"System config: {sys_config}\")\n</code></pre>"},{"location":"api/config-loader/#loading-custom-configurations","title":"Loading Custom Configurations","text":"<pre><code>from src.ConfigLoader import ConfigLoader\n\n# Create loader for custom config file\nloader = ConfigLoader(config_file=\"custom_config.json\")\n\n# Access configuration\ncustom_data = loader.get_system_config()\n</code></pre>"},{"location":"api/config-loader/#configuration-files","title":"Configuration Files","text":""},{"location":"api/config-loader/#system_configjson","title":"system_config.json","text":"<p>Main system configuration file:</p> <pre><code>{\n  \"system\": {\n    \"duet_ip\": \"192.168.1.100\",\n    \"scale_port\": \"/dev/ttyUSB0\",\n    \"scale_baud_rate\": 9600,\n    \"default_feedrate\": \"MEDIUM\"\n  },\n  \"tools\": {\n    \"manipulator\": {\n      \"index\": 0,\n      \"park_position\": {\"x\": 0, \"y\": 0, \"z\": 100},\n      \"v_axis_offset\": 50.0,\n      \"gripper_config\": {\n        \"open_position\": 5.0,\n        \"close_position\": 0.0,\n        \"grip_force\": 10.0\n      }\n    }\n  },\n  \"safety\": {\n    \"max_speed\": 10000,\n    \"acceleration\": 500,\n    \"work_envelope\": {\n      \"x_min\": 0, \"x_max\": 300,\n      \"y_min\": 0, \"y_max\": 300,\n      \"z_min\": 0, \"z_max\": 300\n    }\n  }\n}\n</code></pre>"},{"location":"api/config-loader/#motion_platform_positionsjson","title":"motion_platform_positions.json","text":"<p>State machine positions and transitions:</p> <pre><code>{\n  \"positions\": {\n    \"global_ready\": {\n      \"coordinates\": {\"x\": 150, \"y\": 150, \"z\": 100, \"safe_z\": 150},\n      \"description\": \"Safe global position\",\n      \"requires_tool\": null,\n      \"allowed_payloads\": [\"empty\", \"mold\", \"mold_with_piston\"]\n    }\n  },\n  \"transitions\": {\n    \"global_ready\": {\n      \"to\": [\"scale_ready\", \"mold_slot_A1\"]\n    }\n  }\n}\n</code></pre>"},{"location":"api/config-loader/#mold_labwarejson","title":"mold_labware.json","text":"<p>Deck layout and labware definitions:</p> <pre><code>{\n  \"deck\": {\n    \"name\": \"Main Deck\",\n    \"dimensions\": {\"width\": 300, \"height\": 300},\n    \"labware\": {\n      \"well_plate_1\": {\n        \"type\": \"well_plate\",\n        \"name\": \"24-Well Plate\",\n        \"rows\": 4,\n        \"columns\": 6,\n        \"origin\": {\"x\": 50, \"y\": 50, \"z\": 10},\n        \"wells\": {\n          \"A1\": {\n            \"position\": {\"x\": 50, \"y\": 50, \"z\": 10},\n            \"ready_pos\": \"mold_slot_A1\",\n            \"capacity_ml\": 10.0\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/config-loader/#accessing-configuration-values","title":"Accessing Configuration Values","text":""},{"location":"api/config-loader/#system-settings","title":"System Settings","text":"<pre><code>from src.ConfigLoader import config\n\n# Network settings\nduet_ip = config.get_duet_ip()\nduet_port = config.get_value(\"system.duet_port\", default=80)\n\n# Scale settings\nscale_port = config.get_scale_port()\nscale_baud = config.get_value(\"system.scale_baud_rate\", default=9600)\n\n# Feed rate\nfeedrate = config.get_value(\"system.default_feedrate\", default=\"MEDIUM\")\n</code></pre>"},{"location":"api/config-loader/#tool-configuration","title":"Tool Configuration","text":"<pre><code># Get manipulator configuration\nmanipulator_config = config.get_value(\"tools.manipulator\")\n\nif manipulator_config:\n    index = manipulator_config[\"index\"]\n    park_pos = manipulator_config[\"park_position\"]\n    gripper = manipulator_config[\"gripper_config\"]\n\n    print(f\"Manipulator index: {index}\")\n    print(f\"Park position: {park_pos}\")\n    print(f\"Gripper open: {gripper['open_position']}mm\")\n</code></pre>"},{"location":"api/config-loader/#safety-parameters","title":"Safety Parameters","text":"<pre><code># Get safety limits\nsafety = config.get_value(\"safety\")\n\nif safety:\n    max_speed = safety[\"max_speed\"]\n    envelope = safety[\"work_envelope\"]\n\n    print(f\"Max speed: {max_speed} mm/min\")\n    print(f\"Work envelope: X={envelope['x_min']}-{envelope['x_max']}mm\")\n</code></pre>"},{"location":"api/config-loader/#nested-values","title":"Nested Values","text":"<pre><code># Access deeply nested values using dot notation\ngripper_open = config.get_value(\n    \"tools.manipulator.gripper_config.open_position\",\n    default=5.0\n)\n\n# Or access step by step\ntools = config.get_value(\"tools\")\nmanipulator = tools.get(\"manipulator\", {})\ngripper_config = manipulator.get(\"gripper_config\", {})\ngripper_open = gripper_config.get(\"open_position\", 5.0)\n</code></pre>"},{"location":"api/config-loader/#default-values","title":"Default Values","text":""},{"location":"api/config-loader/#providing-defaults","title":"Providing Defaults","text":"<p>Always provide sensible defaults:</p> <pre><code># GOOD - with default\nvalue = config.get_value(\"optional.setting\", default=100)\n\n# RISKY - no default (might be None)\nvalue = config.get_value(\"optional.setting\")\nif value is None:\n    value = 100\n</code></pre>"},{"location":"api/config-loader/#common-defaults","title":"Common Defaults","text":"<pre><code># Network\nduet_ip = config.get_duet_ip() or \"192.168.1.100\"\nduet_port = config.get_value(\"system.duet_port\", default=80)\n\n# Serial\nscale_port = config.get_scale_port() or \"/dev/ttyUSB0\"\nscale_baud = config.get_value(\"system.scale_baud_rate\", default=9600)\n\n# Performance\nfeedrate = config.get_value(\"system.default_feedrate\", default=\"MEDIUM\")\nmax_speed = config.get_value(\"safety.max_speed\", default=10000)\n</code></pre>"},{"location":"api/config-loader/#configuration-validation","title":"Configuration Validation","text":""},{"location":"api/config-loader/#validating-required-fields","title":"Validating Required Fields","text":"<pre><code>def validate_system_config(config):\n    \"\"\"Validate that required configuration fields exist.\"\"\"\n    required_fields = [\n        \"system.duet_ip\",\n        \"system.scale_port\",\n        \"tools.manipulator.index\"\n    ]\n\n    missing = []\n    for field in required_fields:\n        if config.get_value(field) is None:\n            missing.append(field)\n\n    if missing:\n        raise ValueError(f\"Missing required config fields: {missing}\")\n\n    print(\"\u2705 Configuration validation passed\")\n\n# Usage\ntry:\n    validate_system_config(config)\nexcept ValueError as e:\n    print(f\"\u274c Configuration error: {e}\")\n</code></pre>"},{"location":"api/config-loader/#validating-value-ranges","title":"Validating Value Ranges","text":"<pre><code>def validate_safety_limits(config):\n    \"\"\"Validate safety parameters are within acceptable ranges.\"\"\"\n    safety = config.get_value(\"safety\", default={})\n\n    max_speed = safety.get(\"max_speed\", 10000)\n    if max_speed &gt; 20000:\n        print(f\"\u26a0\ufe0f  Warning: max_speed ({max_speed}) exceeds recommended limit\")\n\n    envelope = safety.get(\"work_envelope\", {})\n    for axis in [\"x\", \"y\", \"z\"]:\n        min_val = envelope.get(f\"{axis}_min\", 0)\n        max_val = envelope.get(f\"{axis}_max\", 300)\n\n        if min_val &gt;= max_val:\n            raise ValueError(f\"Invalid work envelope: {axis}_min &gt;= {axis}_max\")\n\n    print(\"\u2705 Safety limits validation passed\")\n</code></pre>"},{"location":"api/config-loader/#configuration-modification","title":"Configuration Modification","text":""},{"location":"api/config-loader/#runtime-modification","title":"Runtime Modification","text":"<pre><code># Modify configuration at runtime (not persistent)\nconfig._config[\"system\"][\"duet_ip\"] = \"192.168.1.200\"\n\n# Verify change\nnew_ip = config.get_duet_ip()\nprint(f\"New IP: {new_ip}\")\n</code></pre> <p>Not Persistent</p> <p>Runtime modifications are not saved to the configuration file. They only affect the current program execution.</p>"},{"location":"api/config-loader/#saving-configuration","title":"Saving Configuration","text":"<p>To make persistent changes, edit the JSON files directly:</p> <pre><code>import json\nfrom pathlib import Path\n\ndef update_duet_ip(new_ip):\n    \"\"\"Update Duet IP in configuration file.\"\"\"\n    config_file = Path(\"jubilee_api_config/system_config.json\")\n\n    # Read current config\n    with open(config_file, 'r') as f:\n        config_data = json.load(f)\n\n    # Update value\n    config_data[\"system\"][\"duet_ip\"] = new_ip\n\n    # Write back\n    with open(config_file, 'w') as f:\n        json.dump(config_data, f, indent=2)\n\n    print(f\"Updated Duet IP to {new_ip}\")\n\n# Usage\nupdate_duet_ip(\"192.168.1.200\")\n</code></pre>"},{"location":"api/config-loader/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"api/config-loader/#multiple-environments","title":"Multiple Environments","text":"<p>Manage different configurations for different environments:</p> <pre><code>import os\nfrom src.ConfigLoader import ConfigLoader\n\n# Determine environment\nenv = os.getenv(\"JUBILEE_ENV\", \"production\")\n\n# Load environment-specific config\nif env == \"development\":\n    config = ConfigLoader(config_file=\"config/dev_system_config.json\")\nelif env == \"testing\":\n    config = ConfigLoader(config_file=\"config/test_system_config.json\")\nelse:\n    config = ConfigLoader(config_file=\"jubilee_api_config/system_config.json\")\n\nprint(f\"Loaded {env} configuration\")\n</code></pre>"},{"location":"api/config-loader/#configuration-profiles","title":"Configuration Profiles","text":"<pre><code>CONFIGS = {\n    \"lab1\": {\n        \"duet_ip\": \"192.168.1.100\",\n        \"scale_port\": \"/dev/ttyUSB0\"\n    },\n    \"lab2\": {\n        \"duet_ip\": \"192.168.1.200\",\n        \"scale_port\": \"/dev/ttyUSB1\"\n    }\n}\n\ndef load_profile(profile_name):\n    \"\"\"Load a specific configuration profile.\"\"\"\n    profile = CONFIGS.get(profile_name)\n    if not profile:\n        raise ValueError(f\"Unknown profile: {profile_name}\")\n\n    # Apply profile settings\n    # (This would need to be integrated with ConfigLoader)\n    return profile\n\n# Usage\nprofile = load_profile(\"lab1\")\n</code></pre>"},{"location":"api/config-loader/#best-practices","title":"Best Practices","text":""},{"location":"api/config-loader/#use-centralized-config","title":"Use Centralized Config","text":"<pre><code># GOOD - use centralized config\nfrom src.ConfigLoader import config\n\nip = config.get_duet_ip()\n\n# BAD - hardcoded values\nip = \"192.168.1.100\"\n</code></pre>"},{"location":"api/config-loader/#provide-defaults","title":"Provide Defaults","text":"<pre><code># GOOD - safe with default\ntimeout = config.get_value(\"system.timeout\", default=30)\n\n# BAD - might crash if not set\ntimeout = config.get_value(\"system.timeout\")\n</code></pre>"},{"location":"api/config-loader/#validate-on-startup","title":"Validate on Startup","text":"<pre><code>def main():\n    # Validate configuration before using it\n    try:\n        validate_system_config(config)\n        validate_safety_limits(config)\n    except ValueError as e:\n        print(f\"Configuration error: {e}\")\n        return\n\n    # Continue with validated configuration\n    # ...\n</code></pre>"},{"location":"api/config-loader/#document-configuration","title":"Document Configuration","text":"<p>Keep documentation of configuration fields:</p> <pre><code>\"\"\"\nConfiguration Fields:\n\nsystem.duet_ip: str\n    IP address of Jubilee Duet controller\n    Default: \"192.168.1.100\"\n\nsystem.scale_port: str\n    Serial port for scale connection\n    Default: \"/dev/ttyUSB0\"\n\nsystem.default_feedrate: str\n    Default movement speed (SLOW, MEDIUM, FAST)\n    Default: \"MEDIUM\"\n\"\"\"\n</code></pre>"},{"location":"api/config-loader/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Detailed configuration walkthrough</li> <li>JubileeManager - Uses ConfigLoader for initialization</li> <li>System Architecture - Role of configuration in system</li> </ul>"},{"location":"api/jubilee-manager/","title":"JubileeManager API Reference","text":"<p>The <code>JubileeManager</code> class is the primary interface for controlling the Jubilee powder dispensing system. It provides high-level methods for common operations and coordinates multiple hardware components.</p>"},{"location":"api/jubilee-manager/#overview","title":"Overview","text":"<p><code>JubileeManager</code> is designed to be your main entry point for:</p> <ul> <li>Connecting to and managing hardware</li> <li>Performing dispense operations</li> <li>Reading scale weights</li> <li>Coordinating complex multi-step operations</li> </ul> <p>All movements are validated through an internal <code>MotionPlatformStateMachine</code> which cannot be bypassed, ensuring safety and consistency.</p>"},{"location":"api/jubilee-manager/#class-reference","title":"Class Reference","text":""},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager","title":"JubileeManager","text":"<pre><code>JubileeManager(num_piston_dispensers=0, num_pistons_per_dispenser=0, feedrate=MEDIUM)\n</code></pre> <p>High-level manager for Jubilee powder dispensing operations.</p> <p>JubileeManager provides a simplified interface for controlling the Jubilee for powder dispensing tasks.  It coordinates multiple hardware components (machine, scale, dispensers, manipulator) and ensures all operations are safe through state machine validation.</p> <p>All movements are validated through the MotionPlatformStateMachine, which is owned by this manager and cannot be bypassed. This ensures safety and prevents invalid state transitions.</p> ATTRIBUTE DESCRIPTION <code>scale</code> <p>Connected scale instance for weight measurements, or None if not connected.</p> <p> TYPE: <code>Optional[Scale]</code> </p> <code>manipulator</code> <p>Manipulator tool instance for mold handling, or None if not initialized.</p> <p> TYPE: <code>Optional[Manipulator]</code> </p> <code>state_machine</code> <p>Internal state machine for movement validation, or None before connection.</p> <p> TYPE: <code>Optional[MotionPlatformStateMachine]</code> </p> <code>connected</code> <p>Boolean indicating whether hardware is connected and ready.</p> <p> TYPE: <code>bool</code> </p> Example <p>Basic usage pattern::</p> <pre><code>manager = JubileeManager(num_piston_dispensers=2, num_pistons_per_dispenser=10)\n\ntry:\n    if manager.connect():\n        weight = manager.get_weight_stable()\n        manager.dispense_to_well(\"A1\", 50.0)\nfinally:\n    manager.disconnect()\n</code></pre> Note <ul> <li>Always call <code>disconnect()</code> when done to properly release hardware resources</li> <li>Check <code>connected</code> property before performing operations</li> <li>Use <code>machine_read_only</code> only for queries, never for movements</li> </ul> <p>Initialize the JubileeManager.</p> <p>Creates a new manager instance with specified dispenser configuration. Does not connect to hardware - call <code>connect()</code> to establish connections.</p> PARAMETER DESCRIPTION <code>num_piston_dispensers</code> <p>Number of piston dispenser units to initialize. Each dispenser can hold multiple pistons. Default is 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>num_pistons_per_dispenser</code> <p>Initial number of pistons in each dispenser. Used to track available pistons. Default is 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>feedrate</code> <p>Default movement speed for operations. Options are SLOW, MEDIUM, or FAST from the FeedRate enum. Default is MEDIUM.</p> <p> TYPE: <code>FeedRate</code> DEFAULT: <code>MEDIUM</code> </p> Example <pre><code># Create manager with 2 dispensers, 10 pistons each, medium speed\nmanager = JubileeManager(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10,\n    feedrate=FeedRate.MEDIUM\n)\n</code></pre> Note <ul> <li>No hardware connection is established during initialization</li> <li>Dispenser counts can be zero if pistons are not needed</li> <li>Feedrate affects all subsequent movements after connection</li> </ul>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager-attributes","title":"Attributes","text":""},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.machine_read_only","title":"machine_read_only  <code>property</code>","text":"<pre><code>machine_read_only\n</code></pre> <p>Read-only access to the underlying Jubilee Machine instance.</p> <p>Provides access to the Machine object for read operations only (queries, status checks, position reads). While it's technically possible to perform write operations through this property, doing so bypasses the state machine  safety guarantee and should be avoided.</p> RETURNS DESCRIPTION <code>Optional[Machine]</code> <p>The Machine instance if connected, None otherwise.</p> Warning <p>This property is named \"read_only\" as a strong hint that it should ONLY be used for read operations. Performing movements or state changes through this property bypasses the state machine safety guarantee and can lead to:</p> <ul> <li>Collisions with labware</li> <li>Invalid state transitions</li> <li>Unsafe operations</li> <li>Loss of state tracking</li> </ul> Example <pre><code># GOOD: Query current position\nif manager.machine_read_only:\n    pos = manager.machine_read_only.get_position()\n    print(f\"Current position: {pos}\")\n\n# BAD: Perform movements (bypasses validation!)\nmanager.machine_read_only.move_to(x=100, y=100)  # Don't do this!\n</code></pre> Note <p>Always use JubileeManager's high-level methods or the state machine's validated methods for any operations that change machine state.</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.deck","title":"deck  <code>property</code>","text":"<pre><code>deck\n</code></pre> <p>Access to the deck configuration and labware layout.</p> <p>Provides access to the Deck object which contains information about labware positions, well plates, and deck layout.</p> RETURNS DESCRIPTION <code>Optional[Deck]</code> <p>The Deck instance if state machine is initialized, None otherwise.</p> Example <pre><code>if manager.deck:\n    labware = manager.deck.get_labware()\n    print(f\"Available labware: {list(labware.keys())}\")\n</code></pre>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.piston_dispensers","title":"piston_dispensers  <code>property</code>","text":"<pre><code>piston_dispensers\n</code></pre> <p>Access to all configured piston dispensers.</p> <p>Provides access to the list of PistonDispenser instances managed by the state machine. Each dispenser tracks its piston count and position.</p> RETURNS DESCRIPTION <code>List[PistonDispenser]</code> <p>List of PistonDispenser instances. Empty list if none configured</p> <code>List[PistonDispenser]</code> <p>or state machine not initialized.</p> Example <pre><code># Check available pistons across all dispensers\nfor dispenser in manager.piston_dispensers:\n    print(f\"Dispenser {dispenser.index}: {dispenser.num_pistons} pistons\")\n\n# Find first dispenser with available pistons\navailable = next(\n    (d for d in manager.piston_dispensers if d.num_pistons &gt; 0),\n    None\n)\n</code></pre>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager-functions","title":"Functions","text":""},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.connect","title":"connect","text":"<pre><code>connect(machine_address=None, scale_port='/dev/ttyUSB0', state_machine_config=None)\n</code></pre> <p>Connect to all hardware and initialize the system.</p> <p>Establishes connections to the Jubilee machine controller and scale, initializes the state machine with configuration, sets up dispensers, and performs homing operations to establish a known state.</p> <p>This method performs the following sequence:</p> <ol> <li>Connect to Jubilee machine (Duet controller)</li> <li>Connect to precision scale</li> <li>Initialize state machine with configuration</li> <li>Initialize deck layout and piston dispensers</li> <li>Create and configure manipulator tool</li> <li>Home all machine axes (X, Y, Z, U)</li> <li>Pick up manipulator tool</li> <li>Home manipulator axis (V)</li> </ol> PARAMETER DESCRIPTION <code>machine_address</code> <p>IP address of the Jubilee's Duet controller. If None, uses the IP address from system configuration file. Examples: \"192.168.1.100\", \"10.0.0.50\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>scale_port</code> <p>Serial port path for scale connection. Common values: Linux: \"/dev/ttyUSB0\", \"/dev/ttyACM0\" Windows: \"COM3\", \"COM4\" macOS: \"/dev/tty.usbserial-*\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'/dev/ttyUSB0'</code> </p> <code>state_machine_config</code> <p>Path to JSON file defining state machine positions and transitions. Relative or absolute path accepted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all connections and initializations succeeded, False if any</p> <code>bool</code> <p>step failed. Check the <code>connected</code> property after calling.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If state_machine_config file does not exist.</p> <code>RuntimeError</code> <p>If homing, tool pickup, or manipulator homing fails.</p> <code>ConnectionError</code> <p>If unable to connect to machine or scale.</p> Example <pre><code>manager = JubileeManager(num_piston_dispensers=2, num_pistons_per_dispenser=10)\n\n# Connect with explicit IP\nif manager.connect(machine_address=\"192.168.1.100\", scale_port=\"/dev/ttyUSB0\"):\n    print(\"Connected successfully!\")\nelse:\n    print(\"Connection failed - check hardware and configuration\")\n\n# Connect using config file IP\nif manager.connect():  # Uses IP from system_config.json\n    print(\"Connected using configured IP\")\n</code></pre> Note <ul> <li>This operation can take 30-60 seconds due to homing</li> <li>All axes must be clear of obstacles before homing</li> <li>Ensure no tool is already picked up before calling</li> <li>Connection state is stored in <code>self.connected</code> property</li> <li>On failure, partial connections are not cleaned up automatically</li> </ul> Warning <p>If connection fails partway through (e.g., after machine connects but before homing completes), you may need to manually reset the hardware before attempting to connect again.</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from all hardware components and release resources.</p> <p>Cleanly disconnects from the Jubilee machine and scale, releasing any held resources. This should always be called when done using the manager.</p> Example <pre><code>manager = JubileeManager()\ntry:\n    manager.connect()\n    # ... perform operations ...\nfinally:\n    manager.disconnect()  # Always disconnect\n</code></pre> Note <ul> <li>Safe to call multiple times</li> <li>Safe to call even if not fully connected</li> <li>Does not raise exceptions on disconnection errors</li> <li>Sets <code>connected</code> property to False</li> </ul>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.get_weight_stable","title":"get_weight_stable","text":"<pre><code>get_weight_stable()\n</code></pre> <p>Get current weight from scale, waiting for stability.</p> <p>Reads the scale weight, waiting for the reading to stabilize before returning. This is the recommended method for measurements that will be recorded or used for decisions.</p> RETURNS DESCRIPTION <code>float</code> <p>Weight in grams. Returns 0.0 if scale is not connected or on error.</p> Example <pre><code># Get stable reading for recording\nweight = manager.get_weight_stable()\nprint(f\"Stable weight: {weight:.3f}g\")\n\n# Use in conditional\nif manager.get_weight_stable() &gt; 50.0:\n    print(\"Target weight exceeded\")\n</code></pre> Note <ul> <li>Waits for scale to report stable reading (may take 1-3 seconds)</li> <li>More accurate than <code>get_weight_unstable()</code></li> <li>Returns 0.0 on error rather than raising exceptions</li> <li>Check <code>scale.is_connected</code> if you need to distinguish no scale from zero weight</li> </ul> See Also <p>get_weight_unstable: For real-time weight monitoring without waiting</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.get_weight_unstable","title":"get_weight_unstable","text":"<pre><code>get_weight_unstable()\n</code></pre> <p>Get instantaneous weight from scale without waiting for stability.</p> <p>Reads the current scale weight immediately, without waiting for the reading to stabilize. Useful for real-time monitoring but not recommended for recorded measurements.</p> RETURNS DESCRIPTION <code>float</code> <p>Current weight in grams. Returns 0.0 if scale is not connected or on error.</p> Example <pre><code># Monitor weight in real-time during filling\nwhile filling:\n    current = manager.get_weight_unstable()\n    print(f\"Current: {current:.2f}g\", end='\n')\n    time.sleep(0.1)\n\n# Get final stable reading\nfinal = manager.get_weight_stable()\n</code></pre> Note <ul> <li>Returns immediately without waiting</li> <li>Reading may still be changing (unstable)</li> <li>Not suitable for decisions or permanent records</li> <li>Use <code>get_weight_stable()</code> for measurements you'll record</li> <li>Returns 0.0 on error rather than raising exceptions</li> </ul> See Also <p>get_weight_stable: For accurate measurements after stabilization</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.dispense_to_well","title":"dispense_to_well","text":"<pre><code>dispense_to_well(well_id, target_weight)\n</code></pre> <p>Perform complete powder dispense operation to a well.</p> <p>This is the primary high-level operation for dispensing powder. It performs a complete workflow including picking up the mold, filling with powder to target weight, retrieving a piston, and returning the mold to its slot.</p> <p>The operation sequence is:</p> <ol> <li>Move to mold slot position</li> <li>Pick up empty mold from slot</li> <li>Move to scale</li> <li>Place mold on scale</li> <li>Fill with powder to target weight</li> <li>Pick up filled mold from scale</li> <li>Move to piston dispenser</li> <li>Retrieve piston from dispenser</li> <li>Move back to mold slot</li> <li>Place mold (now with powder and piston) back in slot</li> </ol> PARAMETER DESCRIPTION <code>well_id</code> <p>Identifier for the target well/mold slot. Must match an entry in the deck configuration (e.g., \"A1\", \"B2\", \"C3\").</p> <p> TYPE: <code>str</code> </p> <code>target_weight</code> <p>Target weight of powder to dispense, in grams. The system will fill until this weight is reached (within tolerance).</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the entire operation completed successfully, False if any step</p> <code>bool</code> <p>failed or if not connected.</p> RAISES DESCRIPTION <code>ToolStateError</code> <p>If manipulator or scale is not available.</p> <code>RuntimeError</code> <p>If state machine is not configured.</p> <code>ValueError</code> <p>If well_id is not found in deck configuration.</p> Example <pre><code>manager = JubileeManager(num_piston_dispensers=2, num_pistons_per_dispenser=10)\n\nif manager.connect():\n    # Dispense 50g of powder to well A1\n    success = manager.dispense_to_well(\"A1\", target_weight=50.0)\n\n    if success:\n        print(\"Dispense completed successfully!\")\n        weight = manager.get_weight_stable()\n        print(f\"Final weight: {weight}g\")\n    else:\n        print(\"Dispense failed - check logs for details\")\n\n    manager.disconnect()\n</code></pre> Note <ul> <li>Requires at least one dispenser with available pistons</li> <li>All movements are validated through state machine</li> <li>Operation can take 2-5 minutes depending on target weight</li> <li>If operation fails partway through, system may be in intermediate state</li> <li>Check return value before assuming success</li> </ul> Warning <p>If the operation fails after picking up the mold but before returning it, the mold may be left at an intermediate position. Manual intervention may be required to return to a safe state.</p>"},{"location":"api/jubilee-manager/#usage-examples","title":"Usage Examples","text":""},{"location":"api/jubilee-manager/#basic-connection-and-usage","title":"Basic Connection and Usage","text":"<pre><code>from src.JubileeManager import JubileeManager\n\n# Create manager instance\nmanager = JubileeManager(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10\n)\n\n# Connect to hardware\nif manager.connect(machine_address=\"192.168.1.100\"):\n    print(\"Connected successfully!\")\n\n    # Use the manager\n    weight = manager.get_weight_stable()\n    print(f\"Current weight: {weight}g\")\n\n    # Clean up\n    manager.disconnect()\n</code></pre>"},{"location":"api/jubilee-manager/#performing-dispense-operations","title":"Performing Dispense Operations","text":"<pre><code># After connecting...\nsuccess = manager.dispense_to_well(\n    well_id=\"A1\",\n    target_weight=50.0\n)\n\nif success:\n    print(\"Dispense completed successfully!\")\nelse:\n    print(\"Dispense failed - check logs for details\")\n</code></pre>"},{"location":"api/jubilee-manager/#accessing-hardware-components","title":"Accessing Hardware Components","text":"<pre><code># Read-only access to machine (for queries, not movements)\nif manager.machine_read_only:\n    position = manager.machine_read_only.get_position()\n    print(f\"Current position: {position}\")\n\n# Access deck for labware information\nif manager.deck:\n    labware = manager.deck.get_labware()\n    print(f\"Available labware: {labware}\")\n\n# Access piston dispensers\nfor dispenser in manager.piston_dispensers:\n    print(f\"Dispenser {dispenser.index}: {dispenser.num_pistons} pistons\")\n</code></pre>"},{"location":"api/jubilee-manager/#error-handling","title":"Error Handling","text":"<pre><code>from src.JubileeManager import JubileeManager\n\nmanager = JubileeManager()\n\ntry:\n    if not manager.connect():\n        raise ConnectionError(\"Failed to connect to Jubilee\")\n\n    # Perform operations\n    success = manager.dispense_to_well(\"A1\", 50.0)\n    if not success:\n        print(\"Operation failed but system is still connected\")\n\nexcept Exception as e:\n    print(f\"Error occurred: {e}\")\n\nfinally:\n    # Always disconnect\n    manager.disconnect()\n</code></pre>"},{"location":"api/jubilee-manager/#internal-methods","title":"Internal Methods","text":"<p>The following methods are primarily for internal use but are documented for developers:</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager._move_to_mold_slot","title":"_move_to_mold_slot","text":"<pre><code>_move_to_mold_slot(well_id)\n</code></pre> <p>Move to a specific mold slot position.</p> <p>Internal method that moves to the position where the manipulator can pick up or place a mold in the specified well. The target position is determined by the well's configuration in the deck layout.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Identifier for the target well (e.g., \"A1\", \"B2\"). Must exist in the deck configuration's labware definition.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if movement succeeded.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state machine is not configured or movement validation fails. Validation failure reasons include wrong position, wrong tool, or invalid payload state.</p> <code>KeyError</code> <p>If well_id is not found in deck configuration.</p> Note <ul> <li>This is an internal method; typically called by <code>dispense_to_well()</code></li> <li>Uses the well's <code>ready_pos</code> field from deck configuration</li> <li>Movement is validated through state machine</li> <li>Does not pick up or place the mold, only positions for access</li> </ul>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager._move_to_scale","title":"_move_to_scale","text":"<pre><code>_move_to_scale()\n</code></pre> <p>Move to the scale ready position.</p> <p>Internal method that moves the manipulator to the position where it can place or pick up molds on the scale. Movement is validated through the state machine.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if movement succeeded, False if scale is not configured.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state machine is not configured or movement validation fails. Common failure reasons include wrong tool active, invalid payload state, or unable to transition from current position.</p> Note <ul> <li>This is an internal method; typically called by <code>dispense_to_well()</code></li> <li>Moves to scale_ready position defined in state machine config</li> <li>Does not place or pick up mold, only positions for access</li> <li>Movement is validated against current state</li> </ul>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager._move_to_dispenser","title":"_move_to_dispenser","text":"<pre><code>_move_to_dispenser(dispenser_index)\n</code></pre> <p>Move to the ready position for a specific piston dispenser.</p> <p>Internal method that moves the manipulator to the position where it can retrieve a piston from the specified dispenser. Movement is validated through the state machine.</p> PARAMETER DESCRIPTION <code>dispenser_index</code> <p>Index of the target dispenser (0-based). Must be less than the number of configured dispensers.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if movement succeeded, False if not connected, no dispensers, or</p> <code>bool</code> <p>movement validation failed.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state machine is not configured or movement validation fails.</p> <code>ValueError</code> <p>If dispenser_index is out of range.</p> Note <ul> <li>This is an internal method; typically called by <code>dispense_to_well()</code></li> <li>Movement is validated against current state (tool, payload, position)</li> <li>Does not retrieve the piston, only positions for retrieval</li> </ul>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager._fill_powder","title":"_fill_powder","text":"<pre><code>_fill_powder(target_weight)\n</code></pre> <p>Fill mold with powder to target weight.</p> <p>Internal method that dispenses powder into a mold using the trickler mechanism, monitoring the scale until the target weight is reached. The mold must already be placed on the scale.</p> PARAMETER DESCRIPTION <code>target_weight</code> <p>Target weight of powder to dispense, in grams.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if filling succeeded, False if scale is not configured.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state machine is not configured or fill operation validation fails. Validation ensures mold is on scale and system is in correct state for powder dispensing.</p> Note <ul> <li>This is an internal method; typically called by <code>dispense_to_well()</code></li> <li>Mold must already be on the scale before calling</li> <li>Operation continues until target weight is reached (within tolerance)</li> <li>Duration depends on target weight and trickler speed (typically 1-3 min)</li> <li>Continuously monitors scale during filling</li> </ul> Warning <p>Calling this method without a mold on the scale will result in powder being dispensed directly onto the scale, which is incorrect operation.</p>"},{"location":"api/jubilee-manager/#src.JubileeManager.JubileeManager.get_piston_from_dispenser","title":"get_piston_from_dispenser","text":"<pre><code>get_piston_from_dispenser(dispenser_index)\n</code></pre> <p>Retrieve the top piston from a specific dispenser.</p> <p>Retrieves a piston from the specified dispenser and places it into the mold currently held by the manipulator. The operation is validated through the state machine to ensure safety.</p> PARAMETER DESCRIPTION <code>dispenser_index</code> <p>Index of the dispenser to retrieve from (0-based). Must be less than the number of configured dispensers.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if piston was successfully retrieved, False if not connected,</p> <code>bool</code> <p>no dispensers available, or retrieval failed.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state machine is not configured or retrieval validation fails.</p> <code>ValueError</code> <p>If dispenser_index is out of range.</p> Example <pre><code># Manually retrieve piston (typically done by dispense_to_well)\nif manager._move_to_dispenser(0):\n    if manager.get_piston_from_dispenser(0):\n        print(\"Piston retrieved successfully\")\n</code></pre> Note <ul> <li>Must already be at the dispenser ready position (call <code>_move_to_dispenser()</code> first)</li> <li>Requires mold to be held by manipulator</li> <li>Automatically decrements piston count in the dispenser</li> <li>Validation ensures proper state before and after retrieval</li> </ul> Warning <p>Calling this method without first moving to the dispenser position will fail validation. Always call <code>_move_to_dispenser()</code> first.</p>"},{"location":"api/jubilee-manager/#design-notes","title":"Design Notes","text":""},{"location":"api/jubilee-manager/#state-machine-ownership","title":"State Machine Ownership","text":"<p><code>JubileeManager</code> owns the <code>MotionPlatformStateMachine</code> instance. This design ensures:</p> <ul> <li>All movements must go through validation</li> <li>No external code can bypass safety checks</li> <li>Consistent state tracking across the system</li> </ul>"},{"location":"api/jubilee-manager/#read-only-machine-access","title":"Read-Only Machine Access","text":"<p>The <code>machine_read_only</code> property provides access to the underlying <code>Machine</code> object for read operations only. While it's technically possible to perform write operations through this property, doing so bypasses safety validation and is strongly discouraged.</p> <p>Use <code>machine_read_only</code> only for: - Querying current position - Reading sensor values - Checking machine state</p> <p>Never use it for: - Moving axes - Picking/parking tools - Any operation that changes machine state</p>"},{"location":"api/jubilee-manager/#connection-sequence","title":"Connection Sequence","text":"<p>The <code>connect()</code> method performs several initialization steps:</p> <ol> <li>Connects to the Duet controller</li> <li>Connects to the scale</li> <li>Initializes the state machine with configuration</li> <li>Initializes the deck and dispensers</li> <li>Homes all axes (X, Y, Z, U)</li> <li>Picks up the manipulator tool</li> <li>Homes the manipulator axis (V)</li> </ol> <p>This ensures the system is in a known, safe state before operations begin.</p>"},{"location":"api/jubilee-manager/#see-also","title":"See Also","text":"<ul> <li>MotionPlatformStateMachine - For advanced movement control</li> <li>Manipulator - Gripper tool details</li> <li>Scale - Scale interface</li> <li>Quick Start Guide - Getting started tutorial</li> </ul>"},{"location":"api/manipulator/","title":"Manipulator API Reference","text":"<p>The <code>Manipulator</code> class represents the gripper tool with a vertical axis (V-axis) used for picking and placing molds and other objects.</p>"},{"location":"api/manipulator/#overview","title":"Overview","text":"<p>The Manipulator is a custom toolhead that provides:</p> <ul> <li>Gripper: Opens and closes to hold objects</li> <li>V-Axis: Vertical movement independent of machine Z-axis</li> <li>State Integration: Automatically updates state machine context</li> </ul>"},{"location":"api/manipulator/#class-reference","title":"Class Reference","text":""},{"location":"api/manipulator/#src.Manipulator.Manipulator","title":"Manipulator","text":"<pre><code>Manipulator(index, name, state_machine=None, config_source=None)\n</code></pre> <p>               Bases: <code>Tool</code></p> <p>Jubilee toolhead for mold handling and tamping operations. Tracks a Mold object representing the current mold being carried.</p> <p>State tracking: - current_well: Mold object representing the current mold (None if not carrying one) - The Mold object tracks has_top_piston, valid, weight, and other mold properties</p> <p>Operations: - Tamping: Only allowed when carrying a mold without a top piston - Top piston placement: Only allowed when carrying a mold without a top piston - Mold handling: Pick up and place Mold objects</p> <p>Tamping is primarily controlled using sensorless homing/stall detection, which is configured using the M915 command in config.g and homet.g, not this file. driver-stall.g is used to  control tamping after contact with the material.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator-attributes","title":"Attributes","text":""},{"location":"api/manipulator/#src.Manipulator.Manipulator.state_machine","title":"state_machine  <code>instance-attribute</code>","text":"<pre><code>state_machine = state_machine\n</code></pre>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.tamper_axis","title":"tamper_axis  <code>instance-attribute</code>","text":"<pre><code>tamper_axis = 'V'\n</code></pre>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.stall_detection_configured","title":"stall_detection_configured  <code>instance-attribute</code>","text":"<pre><code>stall_detection_configured = False\n</code></pre>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.sensorless_homing_configured","title":"sensorless_homing_configured  <code>instance-attribute</code>","text":"<pre><code>sensorless_homing_configured = False\n</code></pre>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.machine","title":"machine  <code>property</code>","text":"<pre><code>machine\n</code></pre> <p>Access to machine through state machine for read-only queries.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.current_well","title":"current_well  <code>property</code>","text":"<pre><code>current_well\n</code></pre> <p>Access to current well through state machine.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.placed_mold_on_scale","title":"placed_mold_on_scale  <code>property</code>","text":"<pre><code>placed_mold_on_scale\n</code></pre> <p>Access to mold_on_scale state through state machine.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator-functions","title":"Functions","text":""},{"location":"api/manipulator/#src.Manipulator.Manipulator._load_config","title":"_load_config","text":"<pre><code>_load_config(config_source_param)\n</code></pre> <p>Load configuration from either a file path string or a dict.</p> PARAMETER DESCRIPTION <code>config_source_param</code> <p>Either a string (path to JSON file) or a dict (already loaded config)</p> <p> TYPE: <code>Union[str, Dict[str, Any], None]</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>Configuration dictionary, or None if loading failed</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator._load_manipulator_config","title":"_load_manipulator_config","text":"<pre><code>_load_manipulator_config(config_data)\n</code></pre> <p>Load manipulator-specific configuration from config dict (only tamper_axis).</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator._get_config_dict","title":"_get_config_dict","text":"<pre><code>_get_config_dict()\n</code></pre> <p>Helper to package manipulator configuration for state machine calls.</p> <p>Note: Only returns tamper_axis now. State machine should provide: - tamper_travel_pos (from motion_platform_positions.json z_heights) - safe_z (from motion_platform_positions.json z_heights) - dispenser_safe_z (from motion_platform_positions.json z_heights)</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.home_tamper","title":"home_tamper","text":"<pre><code>home_tamper(machine_connection=None)\n</code></pre> <p>Perform sensorless homing for the tamper axis.</p> <p>Validates and executes through MotionPlatformStateMachine.</p> PARAMETER DESCRIPTION <code>machine_connection</code> <p>Deprecated parameter (for backward compatibility)</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.tamp","title":"tamp","text":"<pre><code>tamp(target_depth=None)\n</code></pre> <p>Perform tamping action. Only allowed if carrying a mold without a top piston.</p> PARAMETER DESCRIPTION <code>target_depth</code> <p>Target depth to tamp to (mm). If None, uses default depth.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.vibrate_tamper","title":"vibrate_tamper","text":"<pre><code>vibrate_tamper(machine_connection=None)\n</code></pre>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.get_status","title":"get_status","text":"<pre><code>get_status()\n</code></pre> <p>Get current manipulator status and configuration.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary containing manipulator status information</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.get_current_mold","title":"get_current_mold","text":"<pre><code>get_current_mold()\n</code></pre> <p>Get the current mold being carried.</p> RETURNS DESCRIPTION <code>Optional[Mold]</code> <p>Mold object if carrying a mold, None otherwise</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.is_carrying_mold","title":"is_carrying_mold","text":"<pre><code>is_carrying_mold()\n</code></pre> <p>Check if the manipulator is currently carrying a mold.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if carrying a mold, False otherwise</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.pick_mold","title":"pick_mold","text":"<pre><code>pick_mold(well_id)\n</code></pre> <p>Pick up mold from mold slot.</p> <p>Assumes toolhead is directly above the mold slot at safe_z height with tamper axis in travel position. Validates move through state machine before execution.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Mold slot identifier (numerical string \"0\" through \"17\")</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.place_mold","title":"place_mold","text":"<pre><code>place_mold(well_id)\n</code></pre> <p>Place down the current mold and return it.</p> <p>Assumes toolhead is directly above the mold slot at safe_z height with tamper axis in travel position. Validates move through state machine before execution.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Mold slot identifier (e.g., \"A1\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Mold]</code> <p>The Mold object that was placed, or None if no mold was being carried</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.place_top_piston","title":"place_top_piston","text":"<pre><code>place_top_piston(piston_dispenser)\n</code></pre> <p>Place the top piston on the current mold. Only allowed if carrying a mold without a top piston.</p> <p>Assumes toolhead is at dispenser position. Validates move through state machine before execution.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.place_mold_on_scale","title":"place_mold_on_scale","text":"<pre><code>place_mold_on_scale()\n</code></pre> <p>Place the current mold on the scale. Only allowed if carrying a mold without a top piston.</p> <p>Validates move through state machine before execution.</p>"},{"location":"api/manipulator/#src.Manipulator.Manipulator.pick_mold_from_scale","title":"pick_mold_from_scale","text":"<pre><code>pick_mold_from_scale()\n</code></pre> <p>Pick up the current mold from the scale. Only allowed if carrying a mold without a top piston.</p> <p>Validates move through state machine before execution.</p>"},{"location":"api/manipulator/#exceptions","title":"Exceptions","text":""},{"location":"api/manipulator/#toolstateerror","title":"ToolStateError","text":"<pre><code>class ToolStateError(Exception)\n</code></pre> <p>Exception raised when a tool operation is attempted in an invalid state.</p> <p>This error is raised when trying to perform operations that require specific tool or payload states that are not currently met.</p> <p>Common Scenarios: - Attempting to pick a mold when already holding one - Trying to place a mold when not holding one - Operating at wrong position for the requested action</p> <p>Example: <pre><code>from src.Manipulator import Manipulator, ToolStateError\n\ntry:\n    manipulator.pick_mold(\"A1\")\nexcept ToolStateError as e:\n    print(f\"Operation failed: {e}\")\n</code></pre></p>"},{"location":"api/manipulator/#usage-examples","title":"Usage Examples","text":""},{"location":"api/manipulator/#creating-a-manipulator","title":"Creating a Manipulator","text":"<pre><code>from src.Manipulator import Manipulator\nfrom src.MotionPlatformStateMachine import MotionPlatformStateMachine\n\n# Assume state_machine is already created\nmanipulator = Manipulator(\n    index=0,                      # Tool index on Jubilee\n    name=\"manipulator\",           # Tool name\n    state_machine=state_machine   # Reference to state machine\n)\n</code></pre>"},{"location":"api/manipulator/#picking-and-placing-molds","title":"Picking and Placing Molds","text":"<pre><code># Pick up a mold from a well\nmanipulator.pick_mold(well_id=\"A1\")\n\n# Place mold on scale\nmanipulator.place_mold_on_scale()\n\n# Pick mold from scale\nmanipulator.pick_mold_from_scale()\n\n# Place mold back in well\nmanipulator.place_mold(well_id=\"A1\")\n</code></pre>"},{"location":"api/manipulator/#gripper-control","title":"Gripper Control","text":"<pre><code># Open gripper\nmanipulator.open_gripper()\n\n# Close gripper\nmanipulator.close_gripper()\n</code></pre>"},{"location":"api/manipulator/#v-axis-movement","title":"V-Axis Movement","text":"<pre><code># Move V-axis to specific position\nmanipulator.move_v_axis(position=50.0)  # 50mm\n\n# Home V-axis\nmanipulator.home_v_axis()\n</code></pre>"},{"location":"api/manipulator/#pick-and-place-operations","title":"Pick and Place Operations","text":""},{"location":"api/manipulator/#pick-mold","title":"Pick Mold","text":"<p>The <code>pick_mold()</code> operation:</p> <ol> <li>Validates current position (must be at mold slot)</li> <li>Opens gripper</li> <li>Moves V-axis down to mold</li> <li>Closes gripper</li> <li>Moves V-axis up with mold</li> <li>Updates payload state to <code>\"mold\"</code></li> </ol> <pre><code>try:\n    manipulator.pick_mold(well_id=\"A1\")\n    print(\"Mold picked successfully\")\nexcept ToolStateError as e:\n    print(f\"Pick failed: {e}\")\n</code></pre> <p>Requirements: - Must be at the correct mold slot position - Payload must be <code>\"empty\"</code> - V-axis must be homed</p>"},{"location":"api/manipulator/#place-mold","title":"Place Mold","text":"<p>The <code>place_mold()</code> operation:</p> <ol> <li>Validates current position</li> <li>Moves V-axis down</li> <li>Opens gripper to release mold</li> <li>Moves V-axis up</li> <li>Updates payload state to <code>\"empty\"</code></li> </ol> <pre><code>try:\n    manipulator.place_mold(well_id=\"A1\")\n    print(\"Mold placed successfully\")\nexcept ToolStateError as e:\n    print(f\"Place failed: {e}\")\n</code></pre> <p>Requirements: - Must be at the correct mold slot position - Payload must be <code>\"mold\"</code> or <code>\"mold_with_piston\"</code></p>"},{"location":"api/manipulator/#scale-operations","title":"Scale Operations","text":"<p>Special methods for scale interaction:</p> <pre><code># Place on scale\nmanipulator.place_mold_on_scale()\n\n# Pick from scale\nmanipulator.pick_mold_from_scale()\n</code></pre> <p>These are similar to regular pick/place but: - Use scale-specific positions and heights - Handle weight measurements properly - Update state appropriately</p>"},{"location":"api/manipulator/#state-management","title":"State Management","text":""},{"location":"api/manipulator/#automatic-state-updates","title":"Automatic State Updates","text":"<p>The Manipulator automatically updates the state machine's payload state:</p> <pre><code># Initially empty\nprint(manipulator.state_machine.context.payload_state)  # \"empty\"\n\n# Pick mold\nmanipulator.pick_mold(\"A1\")\nprint(manipulator.state_machine.context.payload_state)  # \"mold\"\n\n# Place mold\nmanipulator.place_mold(\"A1\")\nprint(manipulator.state_machine.context.payload_state)  # \"empty\"\n</code></pre>"},{"location":"api/manipulator/#payload-states","title":"Payload States","text":"State Description Set By <code>empty</code> Nothing held <code>place_mold()</code>, <code>place_mold_on_scale()</code> <code>mold</code> Holding empty mold <code>pick_mold()</code>, <code>pick_mold_from_scale()</code> <code>mold_with_piston</code> Holding mold with piston Manual update after piston insertion"},{"location":"api/manipulator/#configuration","title":"Configuration","text":""},{"location":"api/manipulator/#loading-configuration","title":"Loading Configuration","text":"<p>The Manipulator loads its configuration from <code>system_config.json</code>:</p> <pre><code>{\n  \"tools\": {\n    \"manipulator\": {\n      \"index\": 0,\n      \"park_position\": {\"x\": 0, \"y\": 0, \"z\": 100},\n      \"v_axis_offset\": 50.0,\n      \"gripper_config\": {\n        \"open_position\": 5.0,\n        \"close_position\": 0.0,\n        \"grip_force\": 10.0\n      },\n      \"mold_heights\": {\n        \"pickup_height\": 15.0,\n        \"clearance_height\": 50.0\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/manipulator/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>index</code>: Tool index on Jubilee (usually 0)</li> <li><code>park_position</code>: Where tool parks when not in use</li> <li><code>v_axis_offset</code>: V-axis offset from machine zero</li> <li><code>gripper_config</code>: Gripper open/close positions and force</li> <li><code>mold_heights</code>: Heights for mold pickup and clearance</li> </ul>"},{"location":"api/manipulator/#accessing-configuration","title":"Accessing Configuration","text":"<pre><code># Get current configuration as dict\nconfig = manipulator._get_config_dict()\nprint(config)\n\n# Configuration is loaded automatically from ConfigLoader\n</code></pre>"},{"location":"api/manipulator/#error-handling","title":"Error Handling","text":""},{"location":"api/manipulator/#toolstateerror_1","title":"ToolStateError","text":"<p>Raised when an operation is attempted in an invalid state:</p> <pre><code>from src.Manipulator import ToolStateError\n\ntry:\n    manipulator.pick_mold(\"A1\")\nexcept ToolStateError as e:\n    print(f\"Operation failed: {e}\")\n    # Common causes:\n    # - Wrong position\n    # - Wrong payload state\n    # - Hardware not connected\n</code></pre>"},{"location":"api/manipulator/#common-error-scenarios","title":"Common Error Scenarios","text":"<p>Picking when not empty: <pre><code># This will raise ToolStateError\nmanipulator.pick_mold(\"A1\")\nmanipulator.pick_mold(\"B1\")  # Error: already holding mold\n</code></pre></p> <p>Placing when empty: <pre><code># This will raise ToolStateError\nmanipulator.place_mold(\"A1\")  # Error: not holding anything\n</code></pre></p> <p>Wrong position: <pre><code># Move to wrong position\nstate_machine.validated_move_to_scale()\n\n# This will raise ToolStateError\nmanipulator.pick_mold(\"A1\")  # Error: not at mold slot\n</code></pre></p>"},{"location":"api/manipulator/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/manipulator/#custom-pickplace-heights","title":"Custom Pick/Place Heights","text":"<p>For special cases, you can modify pickup heights:</p> <pre><code># Get config\nconfig = manipulator._get_config_dict()\n\n# Modify pickup height temporarily\noriginal_height = config[\"mold_heights\"][\"pickup_height\"]\nconfig[\"mold_heights\"][\"pickup_height\"] = 20.0\n\n# Perform operation with custom height\n# (Note: this requires modifying internal state - not recommended)\n\n# Restore original\nconfig[\"mold_heights\"][\"pickup_height\"] = original_height\n</code></pre> <p>Configuration Modification</p> <p>Modifying configuration at runtime can lead to inconsistent state. Prefer editing configuration files instead.</p>"},{"location":"api/manipulator/#direct-v-axis-control","title":"Direct V-Axis Control","text":"<p>For specialized operations:</p> <pre><code># Move to specific V position\nmanipulator.move_v_axis(position=30.0)\n\n# Home before precise operations\nmanipulator.home_v_axis()\n\n# Query current V position\ncurrent_v = manipulator.state_machine.machine.get_position()['v']\nprint(f\"Current V: {current_v}mm\")\n</code></pre>"},{"location":"api/manipulator/#integration-with-state-machine","title":"Integration with State Machine","text":"<p>The Manipulator is tightly integrated with the state machine:</p> <pre><code># Create manipulator with state machine reference\nmanipulator = Manipulator(\n    index=0,\n    name=\"manipulator\",\n    state_machine=state_machine\n)\n\n# Manipulator automatically updates state machine context\nmanipulator.pick_mold(\"A1\")\n\n# State machine knows about the payload\nresult = state_machine.validated_move_to_scale()\nif not result.valid:\n    print(f\"Move failed: {result.reason}\")\n    # Might fail if payload not allowed at scale\n</code></pre>"},{"location":"api/manipulator/#best-practices","title":"Best Practices","text":""},{"location":"api/manipulator/#always-check-state","title":"Always Check State","text":"<p>Before operations, verify the state:</p> <pre><code>def safe_pick_mold(manipulator, well_id):\n    \"\"\"Safely pick a mold with state verification.\"\"\"\n    payload = manipulator.state_machine.context.payload_state\n\n    if payload != \"empty\":\n        print(f\"Cannot pick: currently holding {payload}\")\n        return False\n\n    try:\n        manipulator.pick_mold(well_id)\n        return True\n    except ToolStateError as e:\n        print(f\"Pick failed: {e}\")\n        return False\n</code></pre>"},{"location":"api/manipulator/#use-try-except-blocks","title":"Use Try-Except Blocks","text":"<p>Always handle <code>ToolStateError</code>:</p> <pre><code>try:\n    manipulator.pick_mold(\"A1\")\n    manipulator.place_mold_on_scale()\nexcept ToolStateError as e:\n    print(f\"Operation failed: {e}\")\n    # Handle error appropriately\n    # Maybe release gripper, move to safe position, etc.\n</code></pre>"},{"location":"api/manipulator/#coordinate-with-state-machine","title":"Coordinate with State Machine","text":"<p>Don't bypass state machine validation:</p> <pre><code># GOOD: Use state machine for movements\nresult = state_machine.validated_move_to_mold_slot(\"A1\")\nif result.valid:\n    manipulator.pick_mold(\"A1\")\n\n# BAD: Direct machine control bypasses validation\nmachine.move_to(x=100, y=100, z=50)  # Not validated!\nmanipulator.pick_mold(\"A1\")          # May fail or cause collision\n</code></pre>"},{"location":"api/manipulator/#see-also","title":"See Also","text":"<ul> <li>JubileeManager - High-level interface using Manipulator</li> <li>MotionPlatformStateMachine - State tracking and validation</li> <li>PistonDispenser - Related component</li> <li>Quick Start Guide - Basic usage examples</li> </ul>"},{"location":"api/motion-platform/","title":"MotionPlatformStateMachine API Reference","text":"<p>The <code>MotionPlatformStateMachine</code> provides validated movement control for the Jubilee powder dispensing system. It ensures all operations are safe by tracking system state and enforcing constraints.</p>"},{"location":"api/motion-platform/#overview","title":"Overview","text":"<p>The state machine:</p> <ul> <li>Tracks current position, tool, and payload state</li> <li>Validates all requested movements</li> <li>Enforces safety constraints</li> <li>Provides detailed error messages when operations are invalid</li> </ul> <p>Advanced Usage</p> <p>Most users should interact with <code>JubileeManager</code> instead of using the state machine directly. Only use the state machine when you need operations not provided by <code>JubileeManager</code>.</p>"},{"location":"api/motion-platform/#class-reference","title":"Class Reference","text":""},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine","title":"MotionPlatformStateMachine","text":"<pre><code>MotionPlatformStateMachine(registry, machine, *, context=None, scale=None, feedrate=None)\n</code></pre> <p>               Bases: <code>StateMachine</code></p> <p>Finite state machine responsible for validating and sequencing platform moves.</p> <p>The machine relies on python-statemachine to model the control flow. It maintains awareness of both high-level state (idle, moving, tool engaged) and the current logical position descriptor.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine-attributes","title":"Attributes","text":""},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.idle","title":"idle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle = State('Idle', initial=True)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.moving","title":"moving  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>moving = State('Moving')\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.tool_engaged","title":"tool_engaged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tool_engaged = State('Tool Engaged')\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.begin_motion","title":"begin_motion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>begin_motion = to(moving)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.complete_motion","title":"complete_motion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_motion = to(idle)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.complete_motion_with_tool","title":"complete_motion_with_tool  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_motion_with_tool = to(tool_engaged)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.engage_tool","title":"engage_tool  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>engage_tool = to(tool_engaged)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.disengage_tool","title":"disengage_tool  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disengage_tool = to(idle)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.abort_motion","title":"abort_motion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>abort_motion = to(idle)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._registry","title":"_registry  <code>instance-attribute</code>","text":"<pre><code>_registry = registry\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._actions","title":"_actions  <code>instance-attribute</code>","text":"<pre><code>_actions = actions\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._executor","title":"_executor  <code>instance-attribute</code>","text":"<pre><code>_executor = MovementExecutor(machine, scale=scale, feedrate=feedrate)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.machine","title":"machine  <code>property</code>","text":"<pre><code>machine\n</code></pre> <p>Read-only access to machine for state queries (position, status, etc).</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine-functions","title":"Functions","text":""},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.from_config_file","title":"from_config_file  <code>classmethod</code>","text":"<pre><code>from_config_file(path, machine, *, context_overrides=None, scale=None, feedrate=None)\n</code></pre>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.initialize_deck","title":"initialize_deck","text":"<pre><code>initialize_deck(deck_name='weight_well_deck', config_path=None)\n</code></pre> <p>Initialize the deck with weight wells in each slot.</p> PARAMETER DESCRIPTION <code>deck_name</code> <p>Name of the deck configuration</p> <p> TYPE: <code>str</code> DEFAULT: <code>'weight_well_deck'</code> </p> <code>config_path</code> <p>Path to the deck configuration files</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.initialize_dispensers","title":"initialize_dispensers","text":"<pre><code>initialize_dispensers(num_piston_dispensers=0, num_pistons_per_dispenser=0)\n</code></pre> <p>Initialize piston dispensers.</p> PARAMETER DESCRIPTION <code>num_piston_dispensers</code> <p>Number of piston dispensers</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>num_pistons_per_dispenser</code> <p>Number of pistons in each dispenser</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.get_mold_from_deck","title":"get_mold_from_deck","text":"<pre><code>get_mold_from_deck(well_id)\n</code></pre> <p>Get a mold object from the deck by mold slot ID.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Mold slot identifier (numerical string \"0\" through \"17\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[object]</code> <p>Mold object if found, None otherwise</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_pick_mold","title":"validated_pick_mold","text":"<pre><code>validated_pick_mold(well_id, manipulator_config)\n</code></pre> <p>Validate and execute picking up a mold from a mold slot.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Mold slot identifier (numerical string \"0\" through \"17\")</p> <p> TYPE: <code>str</code> </p> <code>manipulator_config</code> <p>Configuration dict for the manipulator</p> <p> TYPE: <code>Dict[str, object]</code> </p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_place_mold","title":"validated_place_mold","text":"<pre><code>validated_place_mold(well_id, manipulator_config=None)\n</code></pre> <p>Validate and execute placing a mold in a mold slot.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Well identifier (numerical string \"0\" through \"17\")</p> <p> TYPE: <code>str</code> </p> <code>manipulator_config</code> <p>Configuration dict for the manipulator</p> <p> TYPE: <code>Optional[Dict[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_place_mold_on_scale","title":"validated_place_mold_on_scale","text":"<pre><code>validated_place_mold_on_scale(manipulator_config)\n</code></pre> <p>Validate and execute placing mold on scale.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_pick_mold_from_scale","title":"validated_pick_mold_from_scale","text":"<pre><code>validated_pick_mold_from_scale(manipulator_config)\n</code></pre> <p>Validate and execute picking mold from scale.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_place_top_piston","title":"validated_place_top_piston","text":"<pre><code>validated_place_top_piston(piston_dispenser, manipulator_config)\n</code></pre> <p>Validate and execute placing top piston.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_tamp","title":"validated_tamp","text":"<pre><code>validated_tamp(manipulator_config)\n</code></pre> <p>Validate and execute tamping action.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._validate_and_execute","title":"_validate_and_execute","text":"<pre><code>_validate_and_execute(target_position_id=None, action_id=None, additional_requirements=None, execution_func=None, **execution_kwargs)\n</code></pre> <p>Generic validation and execution for movements and tool actions.</p> <p>This method performs comprehensive validation for either: - Position movements (when target_position_id is provided) - Tool actions (when action_id is provided)</p> <p>Validation steps for MOVEMENTS: 1. Checks state machine is not already moving 2. Validates position transition is allowed (current \u2192 target) 3. Validates machine is actually at expected current position 4. Validates z-height policy for target position 5. Validates all requirements for target position 6. If valid, executes the provided function and transitions position</p> <p>Validation steps for ACTIONS: 1. Checks state machine is not already moving 2. Validates action exists in registry 3. Validates tool engagement state (if required/blocked) 4. Validates required tool ID matches 5. Validates position scope (action allowed at current position) 6. Validates action requirements and excludes 7. If valid, executes the provided function (no position change)</p> PARAMETER DESCRIPTION <code>target_position_id</code> <p>The target position identifier (for movements)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>action_id</code> <p>The action identifier (for tool actions)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>additional_requirements</code> <p>Extra requirements beyond position/action requirements</p> <p> TYPE: <code>Optional[Dict[str, object]]</code> DEFAULT: <code>None</code> </p> <code>execution_func</code> <p>Function to execute if validation passes</p> <p> DEFAULT: <code>None</code> </p> <code>**execution_kwargs</code> <p>Arguments to pass to execution function</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with validation outcome</p> RAISES DESCRIPTION <code>ValueError</code> <p>If both or neither target_position_id and action_id are provided</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._validate_and_execute_move","title":"_validate_and_execute_move","text":"<pre><code>_validate_and_execute_move(target_position_id, additional_requirements=None, execution_func=None, **execution_kwargs)\n</code></pre> <p>Internal method to validate and execute position movements.</p> <p>See _validate_and_execute() for full documentation.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._validate_and_execute_action","title":"_validate_and_execute_action","text":"<pre><code>_validate_and_execute_action(action_id, additional_requirements=None, execution_func=None, **execution_kwargs)\n</code></pre> <p>Internal method to validate and execute tool actions.</p> <p>All actions must be defined in the registry (config JSON).</p> <p>See _validate_and_execute_move() for full documentation.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_move_to_mold_slot","title":"validated_move_to_mold_slot","text":"<pre><code>validated_move_to_mold_slot(well_id)\n</code></pre> <p>Validate and execute movement to a specific mold slot.</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Mold slot identifier (numerical string \"0\" through \"17\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_move_to_scale","title":"validated_move_to_scale","text":"<pre><code>validated_move_to_scale()\n</code></pre> <p>Validate and execute movement to the scale.</p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_move_to_dispenser","title":"validated_move_to_dispenser","text":"<pre><code>validated_move_to_dispenser(piston_dispenser)\n</code></pre> <p>Validate and execute movement to a dispenser ready position.</p> PARAMETER DESCRIPTION <code>piston_dispenser</code> <p>PistonDispenser object with ready_pos attribute</p> <p> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_fill_powder","title":"validated_fill_powder","text":"<pre><code>validated_fill_powder(target_weight)\n</code></pre> <p>Validate and execute filling mold with powder.</p> PARAMETER DESCRIPTION <code>target_weight</code> <p>Target weight to fill</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_home_tamper","title":"validated_home_tamper","text":"<pre><code>validated_home_tamper(tamper_axis='V')\n</code></pre> <p>Validate and execute tamper homing (uses home_manipulator action).</p> PARAMETER DESCRIPTION <code>tamper_axis</code> <p>Axis letter for tamper (default 'V')</p> <p> TYPE: <code>str</code> DEFAULT: <code>'V'</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_home_all","title":"validated_home_all","text":"<pre><code>validated_home_all()\n</code></pre> <p>Validate and execute homing for all axes (X, Y, Z, U).</p> <p>This action can be conducted from any position, but requires: - No tool picked up (active_tool_id should not be \"manipulator\") - No mold (payload_state should be \"empty\")</p> <p>Returns machine to global_ready position after homing.</p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_home_manipulator","title":"validated_home_manipulator","text":"<pre><code>validated_home_manipulator(manipulator_axis='V')\n</code></pre> <p>Validate and execute homing for the manipulator axis (V).</p> <p>Requires no mold picked up (payload_state should be \"empty\").</p> PARAMETER DESCRIPTION <code>manipulator_axis</code> <p>Axis letter for manipulator (default 'V')</p> <p> TYPE: <code>str</code> DEFAULT: <code>'V'</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_home_trickler","title":"validated_home_trickler","text":"<pre><code>validated_home_trickler(trickler_axis='W')\n</code></pre> <p>Validate and execute homing for the trickler axis (W).</p> <p>Can be homed at any time with no requirements.</p> PARAMETER DESCRIPTION <code>trickler_axis</code> <p>Axis letter for trickler (default 'W')</p> <p> TYPE: <code>str</code> DEFAULT: <code>'W'</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_pickup_tool","title":"validated_pickup_tool","text":"<pre><code>validated_pickup_tool(tool)\n</code></pre> <p>Validate and execute picking up a tool.</p> <p>Valid from mold_ready or global_ready positions. Requires no tool already picked up and mold_transfer_safe z_height. Returns to global_ready position. Only manipulator tool is currently supported.</p> <p>Note: The machine's pickup_tool() method is decorated with @requires_safe_z, which automatically raises the bed height to deck.safe_z + 20 if it is not already at that height.</p> PARAMETER DESCRIPTION <code>tool</code> <p>The Tool object to pick up (must be manipulator)</p> <p> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_park_tool","title":"validated_park_tool","text":"<pre><code>validated_park_tool()\n</code></pre> <p>Validate and execute parking the current tool.</p> <p>Valid from global_ready position. Requires manipulator tool to be active. Returns to global_ready position.</p> <p>Note: The machine's park_tool() method is decorated with @requires_safe_z, which automatically raises the bed height to deck.safe_z + 20 if it is not already at that height.</p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validated_retrieve_piston","title":"validated_retrieve_piston","text":"<pre><code>validated_retrieve_piston(piston_dispenser, manipulator_config)\n</code></pre> <p>Validate and execute retrieving a piston from a dispenser. This action retrieves the piston, partially inserts it, and then returns to ready position.</p> <p>Requires: - Manipulator tool to be active - Mold without top piston (payload_state: mold_without_top_piston) - Must start from the corresponding dispenser_ready position for that dispenser</p> PARAMETER DESCRIPTION <code>piston_dispenser</code> <p>The PistonDispenser object to retrieve from</p> <p> </p> <code>manipulator_config</code> <p>Configuration dict for the manipulator</p> <p> TYPE: <code>Dict[str, object]</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult with outcome</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.request_move","title":"request_move","text":"<pre><code>request_move(request)\n</code></pre> <p>Evaluate and, if permissible, initiate a move or action.</p> <p>If the request references an action, the FSM validates the action without changing state. Otherwise, the FSM transitions into the moving state and records the pending move for completion tracking.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.perform_action","title":"perform_action","text":"<pre><code>perform_action(action_id)\n</code></pre> <p>Validate whether an auxiliary action is permitted.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validate_move","title":"validate_move","text":"<pre><code>validate_move(request)\n</code></pre> <p>Core validation hook for requested moves.</p> This implementation verifies <ul> <li>The target position exists in the registry.</li> <li>The transition between current and target positions is permitted.</li> <li>Z-height and contextual requirements are satisfied.</li> <li>Engaged tools remain constrained to their ready points.</li> </ul>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.complete_move","title":"complete_move","text":"<pre><code>complete_move(*, tool_still_engaged)\n</code></pre> <p>Finalize a move previously initiated via <code>request_move</code>.</p> PARAMETER DESCRIPTION <code>tool_still_engaged</code> <p>Indicates whether the tool engagement status should keep the FSM in the tool_engaged state after the move.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.request_tool_engagement","title":"request_tool_engagement","text":"<pre><code>request_tool_engagement()\n</code></pre> <p>Attempt to transition from idle to tool engaged state at the current position.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.request_tool_disengagement","title":"request_tool_disengagement","text":"<pre><code>request_tool_disengagement()\n</code></pre> <p>Attempt to disengage the tool and return to idle.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.register_tool","title":"register_tool","text":"<pre><code>register_tool(tool_status)\n</code></pre> <p>Introduce or update a tool within the motion context.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.update_tool_engagement","title":"update_tool_engagement","text":"<pre><code>update_tool_engagement(tool_id, engaged)\n</code></pre> <p>Update the engagement flag for a specific tool.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.update_context","title":"update_context","text":"<pre><code>update_context(*, active_tool_id=None, payload_state=None, z_height_id=None)\n</code></pre> <p>Convenience helper to mutate commonly updated context properties.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.validate_machine_state","title":"validate_machine_state","text":"<pre><code>validate_machine_state(machine_x, machine_y, machine_z, machine_v)\n</code></pre> <p>Validate that the machine's physical coordinates match the FSM's expected position.</p> <p>This is a safety check to ensure the machine is actually where the FSM thinks it is. Should be called before attempting moves or actions.</p> PARAMETER DESCRIPTION <code>machine_x</code> <p>Current X coordinate from machine</p> <p> TYPE: <code>float</code> </p> <code>machine_y</code> <p>Current Y coordinate from machine</p> <p> TYPE: <code>float</code> </p> <code>machine_z</code> <p>Current Z coordinate from machine</p> <p> TYPE: <code>float</code> </p> <code>machine_v</code> <p>Current V (manipulator) coordinate from machine</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>MoveValidationResult</code> <p>MoveValidationResult indicating if machine state matches expected position</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.on_enter_moving","title":"on_enter_moving","text":"<pre><code>on_enter_moving()\n</code></pre> <p>Hook invoked when entering the moving state.</p> <p>Future implementations can trigger hardware-level commands or logging from this hook. The current framework simply asserts that a pending move exists when transitions occur.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine.on_enter_idle","title":"on_enter_idle","text":"<pre><code>on_enter_idle()\n</code></pre> <p>Reset pending move tracking when returning to idle.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._assert_engagement_exit_ready","title":"_assert_engagement_exit_ready","text":"<pre><code>_assert_engagement_exit_ready()\n</code></pre> <p>Ensure the machine satisfies engagement requirements before exiting.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._validate_requirements","title":"_validate_requirements","text":"<pre><code>_validate_requirements(requirements)\n</code></pre> <p>Validate context attributes against a requirements mapping.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._validate_excludes","title":"_validate_excludes","text":"<pre><code>_validate_excludes(excludes)\n</code></pre> <p>Validate that context attributes do not match excluded values.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._value_matches","title":"_value_matches  <code>staticmethod</code>","text":"<pre><code>_value_matches(actual, expected)\n</code></pre> <p>Determine whether a context value satisfies an expected requirement.</p>"},{"location":"api/motion-platform/#src.MotionPlatformStateMachine.MotionPlatformStateMachine._format_options","title":"_format_options  <code>staticmethod</code>","text":"<pre><code>_format_options(options)\n</code></pre> <p>Render a collection of options as a comma-separated string.</p>"},{"location":"api/motion-platform/#state-tracking","title":"State Tracking","text":""},{"location":"api/motion-platform/#current-state","title":"Current State","text":"<p>The state machine maintains:</p> <pre><code>{\n    \"position\": \"global_ready\",        # Current named position\n    \"active_tool_id\": 0,               # Active tool (or None)\n    \"payload_state\": \"empty\",          # What manipulator holds\n}\n</code></pre>"},{"location":"api/motion-platform/#payload-states","title":"Payload States","text":"State Description <code>empty</code> Manipulator holds nothing <code>mold</code> Manipulator holds a mold without piston <code>mold_with_piston</code> Manipulator holds a mold containing a piston"},{"location":"api/motion-platform/#position-names","title":"Position Names","text":"<p>Named positions are defined in <code>motion_platform_positions.json</code>:</p> <ul> <li><code>global_ready</code>: Safe position away from all labware</li> <li><code>scale_ready</code>: Position to access the scale</li> <li><code>mold_slot_*</code>: Positions for specific wells (e.g., <code>mold_slot_A1</code>)</li> <li><code>dispenser_*_ready</code>: Positions for piston dispensers</li> </ul>"},{"location":"api/motion-platform/#validation-results","title":"Validation Results","text":"<p>All validated methods return a <code>ValidationResult</code>:</p> <pre><code>@dataclass\nclass ValidationResult:\n    valid: bool       # Whether operation is allowed\n    reason: str = \"\"  # Explanation if not valid\n</code></pre>"},{"location":"api/motion-platform/#example-usage","title":"Example Usage","text":"<pre><code>result = state_machine.validated_move_to_scale()\n\nif result.valid:\n    print(\"Movement successful\")\nelse:\n    print(f\"Movement failed: {result.reason}\")\n</code></pre>"},{"location":"api/motion-platform/#common-operations","title":"Common Operations","text":""},{"location":"api/motion-platform/#homing","title":"Homing","text":"<pre><code># Home all axes (X, Y, Z, U)\nresult = state_machine.validated_home_all()\nif not result.valid:\n    print(f\"Homing failed: {result.reason}\")\n\n# Home manipulator axis (V)\nresult = state_machine.validated_home_manipulator(manipulator_axis='V')\nif not result.valid:\n    print(f\"Manipulator homing failed: {result.reason}\")\n</code></pre> <p>Requirements: - No tool picked up (for <code>validated_home_all</code>) - Payload must be empty - Currently at a named position</p>"},{"location":"api/motion-platform/#tool-management","title":"Tool Management","text":"<pre><code># Pick up a tool\nfrom src.Manipulator import Manipulator\n\nmanipulator = Manipulator(\n    index=0,\n    name=\"manipulator\",\n    state_machine=state_machine\n)\n\nresult = state_machine.validated_pickup_tool(manipulator)\nif not result.valid:\n    print(f\"Tool pickup failed: {result.reason}\")\n\n# Park the current tool\nresult = state_machine.validated_park_tool()\nif not result.valid:\n    print(f\"Tool parking failed: {result.reason}\")\n</code></pre> <p>Requirements: - Must be at appropriate position for tool pickup/parking - Payload must be compatible</p>"},{"location":"api/motion-platform/#position-movements","title":"Position Movements","text":"<pre><code># Move to scale\nresult = state_machine.validated_move_to_scale()\n\n# Move to mold slot\nresult = state_machine.validated_move_to_mold_slot(well_id=\"A1\")\n\n# Move to dispenser\nfrom src.PistonDispenser import PistonDispenser\n\ndispenser = PistonDispenser(index=0, state_machine=state_machine)\nresult = state_machine.validated_move_to_dispenser(\n    piston_dispenser=dispenser\n)\n</code></pre> <p>Requirements vary by destination: - Correct tool must be active - Payload state must be allowed at destination - Valid transition must exist from current position</p>"},{"location":"api/motion-platform/#specialized-operations","title":"Specialized Operations","text":"<pre><code># Fill powder to target weight\nresult = state_machine.validated_fill_powder(target_weight=50.0)\n\n# Retrieve piston from dispenser\nresult = state_machine.validated_retrieve_piston(\n    piston_dispenser=dispenser,\n    manipulator_config=manipulator._get_config_dict()\n)\n</code></pre>"},{"location":"api/motion-platform/#creating-from-configuration","title":"Creating from Configuration","text":""},{"location":"api/motion-platform/#from-file","title":"From File","text":"<pre><code>from pathlib import Path\nfrom science_jubilee.Machine import Machine\nfrom src.Scale import Scale\nfrom src.MotionPlatformStateMachine import MotionPlatformStateMachine\nfrom jubilee_api_config.constants import FeedRate\n\n# Connect to hardware\nmachine = Machine(address=\"192.168.1.100\")\nmachine.connect()\n\nscale = Scale(port=\"/dev/ttyUSB0\")\nscale.connect()\n\n# Create state machine from config\nconfig_path = Path(\"jubilee_api_config/motion_platform_positions.json\")\nstate_machine = MotionPlatformStateMachine.from_config_file(\n    config_file=config_path,\n    machine=machine,\n    scale=scale,\n    feedrate=FeedRate.MEDIUM\n)\n\n# Initialize components\nstate_machine.initialize_deck()\nstate_machine.initialize_dispensers(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10\n)\n</code></pre>"},{"location":"api/motion-platform/#state-updates","title":"State Updates","text":""},{"location":"api/motion-platform/#manual-state-updates","title":"Manual State Updates","text":"<p>In some cases, you may need to manually update the state:</p> <pre><code># Update multiple state fields\nstate_machine.update_context(\n    active_tool_id=0,\n    payload_state=\"mold\"\n)\n\n# Update position\nstate_machine.context.position = \"scale_ready\"\n</code></pre> <p>Manual Updates</p> <p>Manual state updates bypass validation. Only use when you're certain the physical state matches what you're setting.</p>"},{"location":"api/motion-platform/#validation-logic","title":"Validation Logic","text":""},{"location":"api/motion-platform/#position-validation","title":"Position Validation","text":"<p>The state machine validates movements based on:</p> <ol> <li>Current position: Must be at a valid starting position</li> <li>Target position: Must be defined in configuration</li> <li>Transition exists: Direct path must be allowed</li> <li>Tool requirement: Correct tool must be active</li> <li>Payload constraint: Payload must be allowed at target</li> </ol>"},{"location":"api/motion-platform/#example-validation-failure","title":"Example Validation Failure","text":"<pre><code># Trying to move to scale with wrong payload\nstate_machine.context.payload_state = \"invalid_state\"\nresult = state_machine.validated_move_to_scale()\n\n# Result:\n# valid = False\n# reason = \"Payload state 'invalid_state' not allowed at position 'scale_ready'\"\n</code></pre>"},{"location":"api/motion-platform/#configuration-structure","title":"Configuration Structure","text":"<p>The state machine reads from <code>motion_platform_positions.json</code>:</p> <pre><code>{\n  \"positions\": {\n    \"position_name\": {\n      \"coordinates\": {\"x\": 100, \"y\": 100, \"z\": 50, \"safe_z\": 150},\n      \"description\": \"Position description\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"empty\", \"mold\"]\n    }\n  },\n  \"transitions\": {\n    \"from_position\": {\n      \"to\": [\"target_position1\", \"target_position2\"]\n    }\n  }\n}\n</code></pre>"},{"location":"api/motion-platform/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/motion-platform/#custom-movement-sequences","title":"Custom Movement Sequences","text":"<p>For complex operations, chain validated movements:</p> <pre><code>def custom_operation(state_machine, well_id, target_weight):\n    \"\"\"Example custom operation using state machine.\"\"\"\n\n    # Move to mold slot\n    result = state_machine.validated_move_to_mold_slot(well_id)\n    if not result.valid:\n        return False, f\"Move to slot failed: {result.reason}\"\n\n    # Update payload (after picking mold)\n    state_machine.update_context(payload_state=\"mold\")\n\n    # Move to scale\n    result = state_machine.validated_move_to_scale()\n    if not result.valid:\n        return False, f\"Move to scale failed: {result.reason}\"\n\n    # Fill powder\n    result = state_machine.validated_fill_powder(target_weight)\n    if not result.valid:\n        return False, f\"Fill failed: {result.reason}\"\n\n    return True, \"Success\"\n</code></pre>"},{"location":"api/motion-platform/#accessing-internal-state","title":"Accessing Internal State","text":"<pre><code># Get current state\nposition = state_machine.context.position\ntool = state_machine.context.active_tool_id\npayload = state_machine.context.payload_state\n\nprint(f\"State: pos={position}, tool={tool}, payload={payload}\")\n\n# Access components\nmachine = state_machine.machine\nscale = state_machine.context.scale\ndeck = state_machine.context.deck\ndispensers = state_machine.context.piston_dispensers\n</code></pre>"},{"location":"api/motion-platform/#error-handling","title":"Error Handling","text":""},{"location":"api/motion-platform/#common-validation-errors","title":"Common Validation Errors","text":"Error Reason Cause Solution \"Position not found\" Target position not in config Add position to configuration \"No transition defined\" Movement not allowed Add transition or use intermediate position \"Wrong tool active\" Tool requirement not met Pick up required tool first \"Payload not allowed\" Payload state incompatible Change payload or destination \"Tool already picked up\" Tool state conflict Park current tool first"},{"location":"api/motion-platform/#debugging-validation-failures","title":"Debugging Validation Failures","text":"<pre><code>result = state_machine.validated_move_to_scale()\n\nif not result.valid:\n    print(f\"Validation failed: {result.reason}\")\n    print(f\"Current state:\")\n    print(f\"  Position: {state_machine.context.position}\")\n    print(f\"  Tool: {state_machine.context.active_tool_id}\")\n    print(f\"  Payload: {state_machine.context.payload_state}\")\n</code></pre>"},{"location":"api/motion-platform/#thread-safety","title":"Thread Safety","text":"<p>Not Thread-Safe</p> <p>The state machine is not thread-safe. Do not call methods from multiple threads simultaneously. Use appropriate locking if multi-threaded access is required.</p>"},{"location":"api/motion-platform/#see-also","title":"See Also","text":"<ul> <li>JubileeManager - High-level interface (recommended)</li> <li>MovementExecutor - Low-level movement execution</li> <li>Architecture Guide - System design overview</li> <li>Configuration Guide - Setting up positions and transitions</li> </ul>"},{"location":"api/piston-dispenser/","title":"PistonDispenser API Reference","text":"<p>The <code>PistonDispenser</code> class manages containers that hold and dispense cylindrical pistons. It tracks the number of available pistons and their positions.</p>"},{"location":"api/piston-dispenser/#overview","title":"Overview","text":"<p>PistonDispensers:</p> <ul> <li>Hold multiple pistons in a vertical stack</li> <li>Dispense pistons one at a time from the top</li> <li>Track remaining piston count</li> <li>Integrate with the state machine for validated retrieval</li> </ul>"},{"location":"api/piston-dispenser/#class-reference","title":"Class Reference","text":""},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser","title":"PistonDispenser","text":"<pre><code>PistonDispenser(index, num_pistons)\n</code></pre> <p>PistonDispenser is a class representing the piston dispensers on the side of the Jubilee. It is used to keep track of the number of pistons in each dispenser.</p>"},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser-attributes","title":"Attributes","text":""},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index = index\n</code></pre>"},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser.num_pistons","title":"num_pistons  <code>instance-attribute</code>","text":"<pre><code>num_pistons = num_pistons\n</code></pre>"},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser.ready_pos","title":"ready_pos  <code>instance-attribute</code>","text":"<pre><code>ready_pos = f'dispenser_ready_{index}'\n</code></pre>"},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser-functions","title":"Functions","text":""},{"location":"api/piston-dispenser/#src.PistonDispenser.PistonDispenser.remove_piston","title":"remove_piston","text":"<pre><code>remove_piston()\n</code></pre>"},{"location":"api/piston-dispenser/#usage-examples","title":"Usage Examples","text":""},{"location":"api/piston-dispenser/#creating-a-dispenser","title":"Creating a Dispenser","text":"<pre><code>from src.PistonDispenser import PistonDispenser\n\n# Create dispenser with state machine reference\ndispenser = PistonDispenser(\n    index=0,                      # Dispenser index (0, 1, etc.)\n    num_pistons=10,              # Initial piston count\n    state_machine=state_machine   # Reference to state machine\n)\n</code></pre>"},{"location":"api/piston-dispenser/#basic-operations","title":"Basic Operations","text":"<pre><code># Check piston count\nprint(f\"Pistons available: {dispenser.num_pistons}\")\n\n# Dispense a piston (decrements count)\ndispenser.dispense_piston()\nprint(f\"Pistons remaining: {dispenser.num_pistons}\")\n\n# Check if empty\nif dispenser.num_pistons == 0:\n    print(\"Dispenser is empty!\")\n</code></pre>"},{"location":"api/piston-dispenser/#integration-with-jubileemanager","title":"Integration with JubileeManager","text":"<p>Typically used through JubileeManager:</p> <pre><code>from src.JubileeManager import JubileeManager\n\nmanager = JubileeManager(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10\n)\n\nmanager.connect()\n\n# Get piston from dispenser 0\nmanager._move_to_dispenser(dispenser_index=0)\nmanager.get_piston_from_dispenser(dispenser_index=0)\n\n# Check remaining pistons\nfor dispenser in manager.piston_dispensers:\n    print(f\"Dispenser {dispenser.index}: {dispenser.num_pistons} pistons\")\n</code></pre>"},{"location":"api/piston-dispenser/#piston-tracking","title":"Piston Tracking","text":""},{"location":"api/piston-dispenser/#automatic-count-management","title":"Automatic Count Management","text":"<p>The dispenser automatically decrements the piston count:</p> <pre><code>dispenser = PistonDispenser(index=0, num_pistons=5, state_machine=sm)\n\nprint(dispenser.num_pistons)  # 5\ndispenser.dispense_piston()\nprint(dispenser.num_pistons)  # 4\ndispenser.dispense_piston()\nprint(dispenser.num_pistons)  # 3\n</code></pre>"},{"location":"api/piston-dispenser/#checking-availability","title":"Checking Availability","text":"<p>Before attempting to retrieve a piston:</p> <pre><code>if dispenser.num_pistons &gt; 0:\n    dispenser.dispense_piston()\n    print(\"Piston retrieved\")\nelse:\n    print(\"Dispenser empty - needs refilling\")\n</code></pre>"},{"location":"api/piston-dispenser/#position-configuration","title":"Position Configuration","text":"<p>Dispenser positions are configured in <code>mold_labware.json</code>:</p> <pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"piston_dispenser_0\": {\n        \"type\": \"piston_dispenser\",\n        \"name\": \"Dispenser 0\",\n        \"position\": {\"x\": 200, \"y\": 50, \"z\": 20},\n        \"ready_pos\": \"dispenser_0_ready\",\n        \"capacity\": 20,\n        \"piston_height\": 50.0,\n        \"piston_diameter\": 10.0,\n        \"stack_spacing\": 2.0\n      }\n    }\n  }\n}\n</code></pre> <p>Corresponding state machine position in <code>motion_platform_positions.json</code>:</p> <pre><code>{\n  \"positions\": {\n    \"dispenser_0_ready\": {\n      \"coordinates\": {\"x\": 200, \"y\": 50, \"z\": 100, \"safe_z\": 150},\n      \"description\": \"Ready position for piston dispenser 0\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"mold\"]\n    }\n  }\n}\n</code></pre>"},{"location":"api/piston-dispenser/#height-calculations","title":"Height Calculations","text":""},{"location":"api/piston-dispenser/#stack-height","title":"Stack Height","text":"<p>The dispenser calculates the height of the top piston based on:</p> <ul> <li>Base position</li> <li>Number of remaining pistons</li> <li>Piston height</li> <li>Stack spacing</li> </ul> <pre><code># Internal calculation (simplified)\ntop_piston_z = base_z + (num_pistons * piston_height) + ((num_pistons - 1) * stack_spacing)\n</code></pre>"},{"location":"api/piston-dispenser/#retrieval-position","title":"Retrieval Position","text":"<p>When retrieving a piston:</p> <ol> <li>Calculate current top piston height</li> <li>Move V-axis to approach height (slightly above piston)</li> <li>Descend to grip height</li> <li>Close gripper</li> <li>Ascend with piston</li> <li>Decrement count</li> </ol>"},{"location":"api/piston-dispenser/#multiple-dispensers","title":"Multiple Dispensers","text":""},{"location":"api/piston-dispenser/#working-with-multiple-dispensers","title":"Working with Multiple Dispensers","text":"<pre><code># Initialize multiple dispensers via JubileeManager\nmanager = JubileeManager(\n    num_piston_dispensers=3,\n    num_pistons_per_dispenser=10\n)\n\nmanager.connect()\n\n# Access all dispensers\nfor dispenser in manager.piston_dispensers:\n    print(f\"Dispenser {dispenser.index}: {dispenser.num_pistons} pistons\")\n\n# Get piston from specific dispenser\nmanager._move_to_dispenser(dispenser_index=0)\nmanager.get_piston_from_dispenser(dispenser_index=0)\n\n# Check which dispenser has pistons\nfor dispenser in manager.piston_dispensers:\n    if dispenser.num_pistons &gt; 0:\n        print(f\"Dispenser {dispenser.index} has pistons available\")\n        break\n</code></pre>"},{"location":"api/piston-dispenser/#load-balancing","title":"Load Balancing","text":"<p>Distribute piston usage across dispensers:</p> <pre><code>def get_piston_from_any_dispenser(manager):\n    \"\"\"Get piston from first available dispenser.\"\"\"\n    for dispenser in manager.piston_dispensers:\n        if dispenser.num_pistons &gt; 0:\n            manager._move_to_dispenser(dispenser.index)\n            manager.get_piston_from_dispenser(dispenser.index)\n            return dispenser.index\n\n    raise RuntimeError(\"No dispensers have pistons available\")\n</code></pre>"},{"location":"api/piston-dispenser/#state-machine-integration","title":"State Machine Integration","text":""},{"location":"api/piston-dispenser/#validated-retrieval","title":"Validated Retrieval","text":"<p>Piston retrieval goes through state machine validation:</p> <pre><code>from src.MotionPlatformStateMachine import MotionPlatformStateMachine\n\n# Retrieve piston with validation\nresult = state_machine.validated_retrieve_piston(\n    piston_dispenser=dispenser,\n    manipulator_config=manipulator._get_config_dict()\n)\n\nif result.valid:\n    print(\"Piston retrieved successfully\")\nelse:\n    print(f\"Retrieval failed: {result.reason}\")\n</code></pre>"},{"location":"api/piston-dispenser/#requirements-for-retrieval","title":"Requirements for Retrieval","text":"<ul> <li>Must be at dispenser ready position</li> <li>Manipulator tool must be active</li> <li>Payload must be <code>\"mold\"</code> (retrieving into a mold)</li> <li>Dispenser must have pistons available</li> </ul>"},{"location":"api/piston-dispenser/#error-handling","title":"Error Handling","text":""},{"location":"api/piston-dispenser/#empty-dispenser","title":"Empty Dispenser","text":"<pre><code>try:\n    if dispenser.num_pistons == 0:\n        raise RuntimeError(\"Dispenser is empty\")\n\n    dispenser.dispense_piston()\n\nexcept RuntimeError as e:\n    print(f\"Cannot dispense: {e}\")\n    # Handle refill or switch dispenser\n</code></pre>"},{"location":"api/piston-dispenser/#failed-retrieval","title":"Failed Retrieval","text":"<pre><code>result = state_machine.validated_retrieve_piston(\n    piston_dispenser=dispenser,\n    manipulator_config=config\n)\n\nif not result.valid:\n    print(f\"Retrieval failed: {result.reason}\")\n\n    # Common reasons:\n    # - \"Dispenser has no pistons\"\n    # - \"Not at dispenser position\"\n    # - \"Wrong payload state\"\n    # - \"Wrong tool active\"\n</code></pre>"},{"location":"api/piston-dispenser/#refilling-dispensers","title":"Refilling Dispensers","text":""},{"location":"api/piston-dispenser/#manual-refill","title":"Manual Refill","text":"<pre><code>def refill_dispenser(dispenser, num_pistons):\n    \"\"\"Manually refill a dispenser.\"\"\"\n    dispenser.num_pistons = num_pistons\n    print(f\"Dispenser {dispenser.index} refilled with {num_pistons} pistons\")\n\n# Refill when empty\nfor dispenser in manager.piston_dispensers:\n    if dispenser.num_pistons == 0:\n        refill_dispenser(dispenser, 10)\n</code></pre> <p>Physical Refill Required</p> <p>The software doesn't physically refill the dispenser. You must manually add pistons to the physical dispenser, then update the count in software.</p>"},{"location":"api/piston-dispenser/#tracking-usage","title":"Tracking Usage","text":"<pre><code>def track_dispenser_usage(manager, operation_count):\n    \"\"\"Track piston usage statistics.\"\"\"\n    initial_counts = {d.index: d.num_pistons for d in manager.piston_dispensers}\n\n    # Perform operations...\n\n    final_counts = {d.index: d.num_pistons for d in manager.piston_dispensers}\n\n    print(\"Piston Usage:\")\n    for index in initial_counts:\n        used = initial_counts[index] - final_counts[index]\n        print(f\"  Dispenser {index}: {used} pistons used\")\n</code></pre>"},{"location":"api/piston-dispenser/#best-practices","title":"Best Practices","text":""},{"location":"api/piston-dispenser/#check-before-dispensing","title":"Check Before Dispensing","text":"<p>Always verify pistons are available:</p> <pre><code># GOOD\nif dispenser.num_pistons &gt; 0:\n    dispenser.dispense_piston()\nelse:\n    print(\"Need to refill\")\n\n# BAD\ndispenser.dispense_piston()  # Might go negative!\n</code></pre>"},{"location":"api/piston-dispenser/#monitor-levels","title":"Monitor Levels","text":"<p>Track dispenser levels during operations:</p> <pre><code>def dispense_with_monitoring(manager, well_list):\n    \"\"\"Dispense to wells with dispenser monitoring.\"\"\"\n    for well_id in well_list:\n        # Check dispenser levels\n        available = sum(d.num_pistons for d in manager.piston_dispensers)\n\n        if available == 0:\n            print(\"All dispensers empty - stopping\")\n            break\n\n        if available &lt; 5:\n            print(f\"Warning: Only {available} pistons remaining\")\n\n        # Perform dispense\n        manager.dispense_to_well(well_id, target_weight=50.0)\n</code></pre>"},{"location":"api/piston-dispenser/#coordinate-multiple-dispensers","title":"Coordinate Multiple Dispensers","text":"<p>Use all dispensers efficiently:</p> <pre><code>def select_dispenser(manager):\n    \"\"\"Select dispenser with most pistons.\"\"\"\n    return max(manager.piston_dispensers, key=lambda d: d.num_pistons)\n\n# Use the fullest dispenser\ndispenser = select_dispenser(manager)\nif dispenser.num_pistons &gt; 0:\n    manager._move_to_dispenser(dispenser.index)\n    manager.get_piston_from_dispenser(dispenser.index)\n</code></pre>"},{"location":"api/piston-dispenser/#configuration-examples","title":"Configuration Examples","text":""},{"location":"api/piston-dispenser/#single-dispenser-setup","title":"Single Dispenser Setup","text":"<pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"main_dispenser\": {\n        \"type\": \"piston_dispenser\",\n        \"name\": \"Main Piston Dispenser\",\n        \"position\": {\"x\": 200, \"y\": 50, \"z\": 20},\n        \"ready_pos\": \"dispenser_0_ready\",\n        \"capacity\": 30,\n        \"piston_height\": 45.0,\n        \"piston_diameter\": 8.0,\n        \"stack_spacing\": 1.5\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/piston-dispenser/#multiple-dispenser-setup","title":"Multiple Dispenser Setup","text":"<pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"dispenser_0\": {\n        \"type\": \"piston_dispenser\",\n        \"position\": {\"x\": 200, \"y\": 50, \"z\": 20},\n        \"ready_pos\": \"dispenser_0_ready\",\n        \"capacity\": 20\n      },\n      \"dispenser_1\": {\n        \"type\": \"piston_dispenser\",\n        \"position\": {\"x\": 250, \"y\": 50, \"z\": 20},\n        \"ready_pos\": \"dispenser_1_ready\",\n        \"capacity\": 20\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/piston-dispenser/#see-also","title":"See Also","text":"<ul> <li>JubileeManager - High-level dispenser operations</li> <li>MotionPlatformStateMachine - Validated piston retrieval</li> <li>Manipulator - Gripper operations</li> <li>Configuration Guide - Setting up dispensers</li> </ul>"},{"location":"api/scale/","title":"Scale API Reference","text":"<p>The <code>Scale</code> class provides an interface to precision balance hardware for weight measurements.</p>"},{"location":"api/scale/#overview","title":"Overview","text":"<p>The Scale class:</p> <ul> <li>Connects to balance via USB serial</li> <li>Reads weight measurements</li> <li>Supports stable and unstable readings</li> <li>Handles taring and calibration</li> </ul>"},{"location":"api/scale/#class-reference","title":"Class Reference","text":""},{"location":"api/scale/#src.Scale.Scale","title":"Scale","text":"<pre><code>Scale(port, baudrate=9600, timeout=10, parity=PARITY_NONE, stopbits=STOPBITS_ONE, bytesize=EIGHTBITS)\n</code></pre> <p>Class for a digital scale connected via serial port (A&amp;D FX-120i protocol). Provides methods to send commands and parse responses according to the scale's protocol.</p> <p>Initialize the Scale object and connection parameters. :param port: Serial port (e.g., 'COM1' or '/dev/ttyUSB0') :param baudrate: Baud rate for serial communication :param timeout: Read timeout in seconds :param parity: Parity setting (default: PARITY_NONE) :param stopbits: Stop bits setting (default: STOPBITS_ONE) :param bytesize: Byte size setting (default: EIGHTBITS)</p>"},{"location":"api/scale/#src.Scale.Scale-attributes","title":"Attributes","text":""},{"location":"api/scale/#src.Scale.Scale.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port = port\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.baudrate","title":"baudrate  <code>instance-attribute</code>","text":"<pre><code>baudrate = baudrate\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.parity","title":"parity  <code>instance-attribute</code>","text":"<pre><code>parity = parity\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.stopbits","title":"stopbits  <code>instance-attribute</code>","text":"<pre><code>stopbits = stopbits\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.bytesize","title":"bytesize  <code>instance-attribute</code>","text":"<pre><code>bytesize = bytesize\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.serial","title":"serial  <code>instance-attribute</code>","text":"<pre><code>serial = None\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale._is_connected","title":"_is_connected  <code>instance-attribute</code>","text":"<pre><code>_is_connected = False\n</code></pre>"},{"location":"api/scale/#src.Scale.Scale.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected\n</code></pre> <p>Check if the scale is currently connected. :return: True if connected, False otherwise</p>"},{"location":"api/scale/#src.Scale.Scale-functions","title":"Functions","text":""},{"location":"api/scale/#src.Scale.Scale.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Establish a serial connection to the scale. Raises ScaleException if connection fails.</p>"},{"location":"api/scale/#src.Scale.Scale.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Close the serial connection to the scale.</p>"},{"location":"api/scale/#src.Scale.Scale._handle_specific_error","title":"_handle_specific_error","text":"<pre><code>_handle_specific_error(error, cmd, expect_ack=True, is_dual_ack=False)\n</code></pre> <p>Handle specific error codes with unified retry logic. All retry logic is contained within this function.</p> PARAMETER DESCRIPTION <code>error</code> <p>The ScaleError that was received</p> <p> TYPE: <code>ScaleError</code> </p> <code>cmd</code> <p>The command that was being sent</p> <p> TYPE: <code>str</code> </p> <code>expect_ack</code> <p>Whether the command expects an ACK</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>is_dual_ack</code> <p>Whether the command expects dual ACKs</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if command succeeded after error handling, False otherwise</p> RAISES DESCRIPTION <code>ScaleException</code> <p>If error persists after all retries</p>"},{"location":"api/scale/#src.Scale.Scale._wait_for_ack","title":"_wait_for_ack","text":"<pre><code>_wait_for_ack(timeout=ACK_TIMEOUT)\n</code></pre> <p>Wait for an ACK response from the scale.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>ACK_TIMEOUT</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple of (success: bool, received_data: bytes, error: ScaleError or None)</p> RAISES DESCRIPTION <code>ScaleException</code> <p>If error response received instead of ACK (for non-handled errors)</p>"},{"location":"api/scale/#src.Scale.Scale._send_command","title":"_send_command","text":"<pre><code>_send_command(cmd, expect_data=False)\n</code></pre> <p>Send a command to the scale with retry logic and ACK handling.</p> PARAMETER DESCRIPTION <code>cmd</code> <p>Command string to send</p> <p> TYPE: <code>str</code> </p> <code>expect_data</code> <p>If True, expects a data response after ACK</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Response string from the scale</p> RAISES DESCRIPTION <code>ScaleException</code> <p>If command fails after retries or ACK timeout</p>"},{"location":"api/scale/#src.Scale.Scale.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel the S or SIR command.</p>"},{"location":"api/scale/#src.Scale.Scale.query_weight","title":"query_weight","text":"<pre><code>query_weight()\n</code></pre> <p>Request the weight data immediately (Q command).</p>"},{"location":"api/scale/#src.Scale.Scale.request_stable_weight","title":"request_stable_weight","text":"<pre><code>request_stable_weight()\n</code></pre> <p>Request the weight data when stabilized (S command).</p>"},{"location":"api/scale/#src.Scale.Scale.request_instant_weight","title":"request_instant_weight","text":"<pre><code>request_instant_weight()\n</code></pre> <p>Request the weight data immediately (SI command).</p>"},{"location":"api/scale/#src.Scale.Scale.request_continuous_weight","title":"request_continuous_weight","text":"<pre><code>request_continuous_weight()\n</code></pre> <p>Request the weight data continuously (SIR command).</p>"},{"location":"api/scale/#src.Scale.Scale.request_stable_weight_escp","title":"request_stable_weight_escp","text":"<pre><code>request_stable_weight_escp()\n</code></pre> <p>Request the weight data when stabilized (ESC+P command).</p>"},{"location":"api/scale/#src.Scale.Scale.calibrate","title":"calibrate","text":"<pre><code>calibrate()\n</code></pre> <p>Perform calibration (CAL command).</p>"},{"location":"api/scale/#src.Scale.Scale.calibrate_external","title":"calibrate_external","text":"<pre><code>calibrate_external()\n</code></pre> <p>Calibrate using an external weight (EXC command).</p>"},{"location":"api/scale/#src.Scale.Scale.display_off","title":"display_off","text":"<pre><code>display_off()\n</code></pre> <p>Turn the display off (OFF command).</p>"},{"location":"api/scale/#src.Scale.Scale.display_on","title":"display_on","text":"<pre><code>display_on()\n</code></pre> <p>Turn the display on (ON command).</p>"},{"location":"api/scale/#src.Scale.Scale.power_on","title":"power_on","text":"<pre><code>power_on()\n</code></pre> <p>Alias for turning the display on.</p>"},{"location":"api/scale/#src.Scale.Scale.power_off","title":"power_off","text":"<pre><code>power_off()\n</code></pre> <p>Alias for turning the display off.</p>"},{"location":"api/scale/#src.Scale.Scale.print_weight","title":"print_weight","text":"<pre><code>print_weight()\n</code></pre> <p>Print the current weight (PRT command).</p>"},{"location":"api/scale/#src.Scale.Scale.re_zero","title":"re_zero","text":"<pre><code>re_zero()\n</code></pre> <p>Re-zero the scale (R command).</p>"},{"location":"api/scale/#src.Scale.Scale.sample","title":"sample","text":"<pre><code>sample()\n</code></pre> <p>Sample command (SMP command).</p>"},{"location":"api/scale/#src.Scale.Scale.tare","title":"tare","text":"<pre><code>tare()\n</code></pre> <p>Tare the scale (T command).</p>"},{"location":"api/scale/#src.Scale.Scale.mode","title":"mode","text":"<pre><code>mode()\n</code></pre> <p>Change the weighing mode (U command).</p>"},{"location":"api/scale/#src.Scale.Scale.get_id","title":"get_id","text":"<pre><code>get_id()\n</code></pre> <p>Request the ID number (?ID command).</p>"},{"location":"api/scale/#src.Scale.Scale.get_serial_number","title":"get_serial_number","text":"<pre><code>get_serial_number()\n</code></pre> <p>Request the serial number (?SN command).</p>"},{"location":"api/scale/#src.Scale.Scale.get_model","title":"get_model","text":"<pre><code>get_model()\n</code></pre> <p>Request the model name (?TN command).</p>"},{"location":"api/scale/#src.Scale.Scale.get_tare_weight","title":"get_tare_weight","text":"<pre><code>get_tare_weight()\n</code></pre> <p>Request the tare weight (?PT command).</p>"},{"location":"api/scale/#src.Scale.Scale.set_tare_weight","title":"set_tare_weight","text":"<pre><code>set_tare_weight(value, unit='g')\n</code></pre> <p>Set the tare weight (PT command). :param value: Tare weight value :param unit: Weighing unit (default 'g')</p>"},{"location":"api/scale/#src.Scale.Scale.get_weight","title":"get_weight","text":"<pre><code>get_weight(stable=True)\n</code></pre> <p>Get the current weight from the scale, parsing the response according to the data format. :param stable: If True, waits for stable weight; otherwise, allows unstable :return: The weight in grams</p>"},{"location":"api/scale/#src.Scale.Scale._parse_weight","title":"_parse_weight","text":"<pre><code>_parse_weight(data, expect_stable=True)\n</code></pre> <p>Parse the weight data string from the scale according to the protocol data format. Checks header, sign, value, unit, and overload state. Throws errors for protocol violations. :param data: Raw data string from the scale :param expect_stable: If True, expects 'ST' header; else allows 'ST' or 'US' :return: Parsed weight as float</p>"},{"location":"api/scale/#usage-examples","title":"Usage Examples","text":""},{"location":"api/scale/#basic-connection-and-reading","title":"Basic Connection and Reading","text":"<pre><code>from src.Scale import Scale\n\n# Create and connect to scale\nscale = Scale(port=\"/dev/ttyUSB0\")\nscale.connect()\n\nif scale.is_connected:\n    # Get stable weight reading\n    weight = scale.get_weight(stable=True)\n    print(f\"Weight: {weight}g\")\n\n    # Disconnect when done\n    scale.disconnect()\n</code></pre>"},{"location":"api/scale/#stable-vs-unstable-readings","title":"Stable vs Unstable Readings","text":"<pre><code># Stable reading (waits for weight to stabilize)\nstable_weight = scale.get_weight(stable=True)\nprint(f\"Stable: {stable_weight}g\")\n\n# Unstable reading (immediate, may be changing)\nunstable_weight = scale.get_weight(stable=False)\nprint(f\"Unstable: {unstable_weight}g\")\n</code></pre> <p>When to use each:</p> <ul> <li>Stable: For measurements you'll record or use for decisions</li> <li>Unstable: For real-time monitoring or progress display</li> </ul>"},{"location":"api/scale/#taring-the-scale","title":"Taring the Scale","text":"<pre><code># Tare (zero) the scale\nscale.tare()\n\n# Now readings are relative to current weight\n# Place object on scale\nweight = scale.get_weight(stable=True)\nprint(f\"Object weight: {weight}g\")\n</code></pre>"},{"location":"api/scale/#integration-with-jubileemanager","title":"Integration with JubileeManager","text":"<p>The scale is typically used through JubileeManager:</p> <pre><code>from src.JubileeManager import JubileeManager\n\nmanager = JubileeManager()\nmanager.connect(scale_port=\"/dev/ttyUSB0\")\n\n# Get stable weight\nweight = manager.get_weight_stable()\nprint(f\"Weight: {weight}g\")\n\n# Get unstable weight (faster)\nweight = manager.get_weight_unstable()\nprint(f\"Weight: {weight}g\")\n</code></pre>"},{"location":"api/scale/#weight-monitoring","title":"Weight Monitoring","text":""},{"location":"api/scale/#continuous-monitoring","title":"Continuous Monitoring","text":"<pre><code>import time\n\ndef monitor_weight(scale, duration=10):\n    \"\"\"Monitor weight for specified duration.\"\"\"\n    print(\"Monitoring weight...\")\n    start_time = time.time()\n\n    while time.time() - start_time &lt; duration:\n        weight = scale.get_weight(stable=False)\n        print(f\"Weight: {weight:6.2f}g\", end='\\r')\n        time.sleep(0.1)\n\n    print()  # New line\n\n# Usage\nmonitor_weight(scale, duration=30)\n</code></pre>"},{"location":"api/scale/#waiting-for-stability","title":"Waiting for Stability","text":"<pre><code>def wait_for_stable(scale, timeout=30):\n    \"\"\"Wait for weight to stabilize.\"\"\"\n    import time\n\n    start_time = time.time()\n    previous_weight = None\n    stable_count = 0\n    required_stable_readings = 5\n    tolerance = 0.01  # grams\n\n    while time.time() - start_time &lt; timeout:\n        weight = scale.get_weight(stable=False)\n\n        if previous_weight is not None:\n            if abs(weight - previous_weight) &lt; tolerance:\n                stable_count += 1\n                if stable_count &gt;= required_stable_readings:\n                    return weight, True\n            else:\n                stable_count = 0\n\n        previous_weight = weight\n        time.sleep(0.2)\n\n    return previous_weight, False\n\n# Usage\nweight, is_stable = wait_for_stable(scale)\nif is_stable:\n    print(f\"Stable weight: {weight}g\")\nelse:\n    print(\"Timeout waiting for stability\")\n</code></pre>"},{"location":"api/scale/#configuration","title":"Configuration","text":""},{"location":"api/scale/#serial-port-configuration","title":"Serial Port Configuration","text":"<p>The scale port is configured in <code>system_config.json</code>:</p> <pre><code>{\n  \"system\": {\n    \"scale_port\": \"/dev/ttyUSB0\",\n    \"scale_baud_rate\": 9600,\n    \"scale_timeout\": 2.0\n  }\n}\n</code></pre>"},{"location":"api/scale/#finding-the-serial-port","title":"Finding the Serial Port","text":"<p>Linux: <pre><code># List USB serial devices\nls -l /dev/ttyUSB*\nls -l /dev/ttyACM*\n\n# Check dmesg for recent connections\ndmesg | grep tty\n</code></pre></p> <p>Windows: <pre><code># List COM ports\nGet-WmiObject Win32_SerialPort | Select-Object Name, DeviceID\n</code></pre></p> <p>macOS: <pre><code># List serial devices\nls -l /dev/tty.*\nls -l /dev/cu.*\n</code></pre></p>"},{"location":"api/scale/#error-handling","title":"Error Handling","text":""},{"location":"api/scale/#connection-failures","title":"Connection Failures","text":"<pre><code>from src.Scale import Scale\n\nscale = Scale(port=\"/dev/ttyUSB0\")\n\ntry:\n    scale.connect()\n    if not scale.is_connected:\n        raise ConnectionError(\"Scale connection failed\")\nexcept Exception as e:\n    print(f\"Error connecting to scale: {e}\")\n    # Common causes:\n    # - Wrong port\n    # - Port already in use\n    # - Insufficient permissions\n    # - Hardware not connected\n</code></pre>"},{"location":"api/scale/#reading-failures","title":"Reading Failures","text":"<pre><code>try:\n    weight = scale.get_weight(stable=True)\n    if weight is None:\n        print(\"Failed to read weight\")\nexcept Exception as e:\n    print(f\"Error reading scale: {e}\")\n    # Common causes:\n    # - Communication timeout\n    # - Scale not responding\n    # - Invalid data from scale\n</code></pre>"},{"location":"api/scale/#handling-disconnection","title":"Handling Disconnection","text":"<pre><code>def safe_read_weight(scale):\n    \"\"\"Safely read weight with error handling.\"\"\"\n    if not scale.is_connected:\n        print(\"Scale not connected\")\n        return None\n\n    try:\n        weight = scale.get_weight(stable=True)\n        return weight\n    except Exception as e:\n        print(f\"Error reading weight: {e}\")\n        return None\n</code></pre>"},{"location":"api/scale/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/scale/#calibration","title":"Calibration","text":"<pre><code>def calibrate_scale(scale, known_weight):\n    \"\"\"\n    Calibrate scale using a known reference weight.\n\n    Args:\n        scale: Connected Scale instance\n        known_weight: Weight of calibration standard in grams\n    \"\"\"\n    print(\"Remove all items from scale, then press Enter\")\n    input()\n\n    # Tare the empty scale\n    scale.tare()\n    print(\"Scale tared\")\n\n    print(f\"Place {known_weight}g calibration weight on scale, then press Enter\")\n    input()\n\n    # Read calibration weight\n    measured = scale.get_weight(stable=True)\n    print(f\"Measured: {measured}g\")\n    print(f\"Expected: {known_weight}g\")\n    print(f\"Error: {measured - known_weight}g ({((measured - known_weight) / known_weight) * 100:.2f}%)\")\n\n    if abs(measured - known_weight) &gt; 0.1:\n        print(\"Warning: Calibration error exceeds 0.1g\")\n</code></pre>"},{"location":"api/scale/#data-logging","title":"Data Logging","text":"<pre><code>import csv\nimport time\nfrom datetime import datetime\n\ndef log_weight_data(scale, output_file, duration=60, interval=1.0):\n    \"\"\"\n    Log weight data to CSV file.\n\n    Args:\n        scale: Connected Scale instance\n        output_file: Path to output CSV file\n        duration: How long to log in seconds\n        interval: Time between readings in seconds\n    \"\"\"\n    with open(output_file, 'w', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerow(['Timestamp', 'Weight (g)', 'Stable'])\n\n        start_time = time.time()\n        while time.time() - start_time &lt; duration:\n            timestamp = datetime.now().isoformat()\n\n            # Get both stable and unstable readings\n            unstable = scale.get_weight(stable=False)\n            stable = scale.get_weight(stable=True)\n\n            writer.writerow([timestamp, unstable, 'No'])\n            writer.writerow([timestamp, stable, 'Yes'])\n\n            time.sleep(interval)\n\n    print(f\"Data logged to {output_file}\")\n\n# Usage\nlog_weight_data(scale, \"weight_log.csv\", duration=300, interval=5.0)\n</code></pre>"},{"location":"api/scale/#multi-scale-setup","title":"Multi-Scale Setup","text":"<p>For systems with multiple scales:</p> <pre><code>class ScaleManager:\n    \"\"\"Manage multiple scales.\"\"\"\n\n    def __init__(self, ports):\n        \"\"\"\n        Initialize multiple scales.\n\n        Args:\n            ports: List of serial port paths\n        \"\"\"\n        self.scales = []\n        for i, port in enumerate(ports):\n            scale = Scale(port=port)\n            scale.connect()\n            if scale.is_connected:\n                self.scales.append((i, scale))\n                print(f\"Scale {i} connected on {port}\")\n            else:\n                print(f\"Failed to connect scale {i} on {port}\")\n\n    def read_all(self, stable=True):\n        \"\"\"Read all scales.\"\"\"\n        readings = {}\n        for index, scale in self.scales:\n            readings[index] = scale.get_weight(stable=stable)\n        return readings\n\n    def disconnect_all(self):\n        \"\"\"Disconnect all scales.\"\"\"\n        for index, scale in self.scales:\n            scale.disconnect()\n\n# Usage\nmanager = ScaleManager([\"/dev/ttyUSB0\", \"/dev/ttyUSB1\"])\nreadings = manager.read_all(stable=True)\nprint(f\"Scale readings: {readings}\")\nmanager.disconnect_all()\n</code></pre>"},{"location":"api/scale/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/scale/#scale-not-responding","title":"Scale Not Responding","text":"<p>Symptoms: - <code>is_connected</code> is False - Timeout errors when reading</p> <p>Solutions: 1. Verify physical connection (USB cable plugged in) 2. Check that port is correct (<code>ls /dev/ttyUSB*</code>) 3. Verify user has permission to access serial port:    <pre><code>sudo usermod -a -G dialout $USER\n# Log out and log back in\n</code></pre> 4. Try different USB port 5. Check that no other program is using the scale 6. Verify scale is powered on</p>"},{"location":"api/scale/#incorrect-readings","title":"Incorrect Readings","text":"<p>Symptoms: - Readings don't match display on scale - Readings are always zero - Readings are unstable</p> <p>Solutions: 1. Tare the scale: <code>scale.tare()</code> 2. Calibrate using known weight 3. Check for environmental factors:    - Drafts/air currents    - Vibrations    - Temperature changes 4. Verify scale settings (units, precision) 5. Check baud rate matches scale configuration</p>"},{"location":"api/scale/#permission-denied","title":"Permission Denied","text":"<p>Linux symptom: <code>PermissionError: [Errno 13] Permission denied: '/dev/ttyUSB0'</code></p> <p>Solutions: <pre><code># Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Or use udev rule\nsudo nano /etc/udev/rules.d/50-scale.rules\n# Add: SUBSYSTEM==\"tty\", ATTRS{idVendor}==\"XXXX\", MODE=\"0666\"\n\n# Reload udev rules\nsudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre></p>"},{"location":"api/scale/#best-practices","title":"Best Practices","text":""},{"location":"api/scale/#always-tare-before-measurements","title":"Always Tare Before Measurements","text":"<pre><code># GOOD\nscale.tare()\n# ... place object ...\nweight = scale.get_weight(stable=True)\n\n# BAD\nweight = scale.get_weight(stable=True)  # May include previous object's weight\n</code></pre>"},{"location":"api/scale/#use-stable-readings-for-decisions","title":"Use Stable Readings for Decisions","text":"<pre><code># GOOD - for recording data\nfinal_weight = scale.get_weight(stable=True)\nsave_to_database(final_weight)\n\n# BAD - for recording data\nweight = scale.get_weight(stable=False)  # Might be changing!\nsave_to_database(weight)\n\n# OK - for real-time monitoring\nwhile filling:\n    current = scale.get_weight(stable=False)\n    print(f\"Current: {current}g\")\n</code></pre>"},{"location":"api/scale/#handle-connection-state","title":"Handle Connection State","text":"<pre><code># GOOD\nif scale.is_connected:\n    weight = scale.get_weight(stable=True)\nelse:\n    print(\"Scale not connected\")\n\n# BAD\nweight = scale.get_weight(stable=True)  # Might fail if not connected\n</code></pre>"},{"location":"api/scale/#clean-up-resources","title":"Clean Up Resources","text":"<pre><code># GOOD\nscale = Scale(port=\"/dev/ttyUSB0\")\ntry:\n    scale.connect()\n    # ... use scale ...\nfinally:\n    scale.disconnect()\n\n# BETTER - use context manager (if available)\nwith Scale(port=\"/dev/ttyUSB0\") as scale:\n    weight = scale.get_weight(stable=True)\n</code></pre>"},{"location":"api/scale/#see-also","title":"See Also","text":"<ul> <li>JubileeManager - High-level scale operations</li> <li>Configuration Guide - Setting up scale port</li> <li>Results Interpretation - Analyzing weight data</li> </ul>"},{"location":"concepts/architecture/","title":"System Architecture","text":"<p>This document explains the architecture of the Jubilee Powder system at a conceptual level.</p>"},{"location":"concepts/architecture/#overview","title":"Overview","text":"<p>The Jubilee Powder system uses a layered architecture where each layer provides a different level of abstraction and control.</p>"},{"location":"concepts/architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"User Layer\"\n        A[User Scripts]\n        B[GUI Application]\n    end\n\n    subgraph \"Coordination Layer\"\n        C[JubileeManager]\n    end\n\n    subgraph \"Validation Layer\"\n        D[MotionPlatformStateMachine]\n        E[MovementExecutor]\n    end\n\n    subgraph \"Component Layer\"\n        F[Manipulator]\n        G[PistonDispenser]\n        H[Scale]\n    end\n\n    subgraph \"Hardware Layer\"\n        I[Jubilee Machine]\n        J[Scale Hardware]\n        K[Deck/Labware]\n    end\n\n    subgraph \"Configuration\"\n        L[ConfigLoader]\n        M[JSON Config Files]\n    end\n\n    A --&gt; C\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    C --&gt; H\n    D --&gt; E\n    E --&gt; I\n    F --&gt; D\n    G --&gt; D\n    H --&gt; J\n    D --&gt; K\n    L --&gt; M\n    C --&gt; L\n    D --&gt; L</code></pre>"},{"location":"concepts/architecture/#layer-details","title":"Layer Details","text":""},{"location":"concepts/architecture/#1-user-layer","title":"1. User Layer","text":"<p>Purpose: Entry point for automation tasks</p> <p>Components:</p> <ul> <li>User Scripts: Python scripts written by users to automate specific tasks</li> <li>GUI Application: Browser-based interface for manual control and monitoring</li> </ul> <p>Responsibilities:</p> <ul> <li>Define high-level workflows</li> <li>Handle application-specific logic</li> <li>Interpret results and make decisions</li> </ul>"},{"location":"concepts/architecture/#2-coordination-layer","title":"2. Coordination Layer","text":"<p>Purpose: Coordinate complex multi-component operations</p> <p>Components:</p> <ul> <li>JubileeManager: Central orchestrator for all operations</li> </ul> <p>Responsibilities:</p> <ul> <li>Connect to and manage all hardware components</li> <li>Provide high-level API for common operations</li> <li>Coordinate multi-step operations (e.g., dispense_to_well)</li> <li>Handle errors and provide meaningful feedback</li> </ul> <p>Key Design Decisions:</p> <ul> <li>Single point of access for most operations</li> <li>Owns the state machine (cannot be bypassed)</li> <li>Provides both convenience methods and component access</li> </ul>"},{"location":"concepts/architecture/#3-validation-layer","title":"3. Validation Layer","text":"<p>Purpose: Ensure all operations are safe and valid</p> <p>Components:</p> <ul> <li>MotionPlatformStateMachine: Validates and executes movements</li> <li>MovementExecutor: Executes validated movements on hardware</li> </ul> <p>Responsibilities:</p> <ul> <li>Track current system state (position, tool, payload)</li> <li>Validate requested movements against current state</li> <li>Enforce movement constraints and safe zones</li> <li>Provide detailed error messages for invalid requests</li> <li>Execute validated movements</li> </ul> <p>State Machine States:</p> <p>The state machine tracks:</p> <ul> <li>Position: Current named position (e.g., \"global_ready\", \"scale_ready\")</li> <li>Active Tool: Which tool is currently picked up (or None)</li> <li>Payload: What the manipulator is holding (empty, mold, mold_with_piston)</li> </ul> <p>Validation Rules:</p> <ul> <li>Tool must be picked up to move to certain positions</li> <li>Payload state affects which movements are allowed</li> <li>Some operations require specific starting positions</li> </ul>"},{"location":"concepts/architecture/#4-component-layer","title":"4. Component Layer","text":"<p>Purpose: Represent individual hardware components</p> <p>Components:</p> <ul> <li>Manipulator: Gripper tool with vertical axis</li> <li>PistonDispenser: Container for pistons with tracking</li> <li>Scale: Weight measurement device</li> </ul> <p>Responsibilities:</p> <ul> <li>Encapsulate component-specific logic</li> <li>Provide component-specific operations</li> <li>Maintain component state</li> <li>Interact with validation layer for movements</li> </ul>"},{"location":"concepts/architecture/#5-hardware-layer","title":"5. Hardware Layer","text":"<p>Purpose: Physical hardware interface</p> <p>Components:</p> <ul> <li>Jubilee Machine: CNC motion platform (via science-jubilee library)</li> <li>Scale Hardware: Precision balance (via serial connection)</li> <li>Deck/Labware: Physical deck layout and labware definitions</li> </ul> <p>Responsibilities:</p> <ul> <li>Execute physical movements</li> <li>Report sensor readings</li> <li>Handle low-level communication protocols</li> </ul>"},{"location":"concepts/architecture/#6-configuration","title":"6. Configuration","text":"<p>Purpose: Centralize system configuration</p> <p>Components:</p> <ul> <li>ConfigLoader: Loads and provides access to configuration</li> <li>JSON Config Files: Define positions, deck layouts, system parameters</li> </ul> <p>Configuration Files:</p> <ul> <li><code>motion_platform_positions.json</code>: State machine positions and transitions</li> <li><code>system_config.json</code>: System-level settings</li> <li><code>mold_labware.json</code>: Deck layout and labware definitions</li> <li><code>weight_well_deck.json</code>: Well-specific configurations</li> </ul>"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":""},{"location":"concepts/architecture/#example-dispense-to-well-operation","title":"Example: Dispense to Well Operation","text":"<p>Let's trace how a <code>dispense_to_well</code> operation flows through the system:</p> <pre><code>sequenceDiagram\n    participant U as User Script\n    participant JM as JubileeManager\n    participant SM as StateMachine\n    participant M as Manipulator\n    participant S as Scale\n    participant H as Hardware\n\n    U-&gt;&gt;JM: dispense_to_well(\"A1\", 50.0)\n    JM-&gt;&gt;SM: validated_move_to_mold_slot(\"A1\")\n    SM-&gt;&gt;SM: Check current state\n    SM-&gt;&gt;SM: Validate movement\n    SM-&gt;&gt;H: Execute movement\n    H--&gt;&gt;SM: Movement complete\n    SM--&gt;&gt;JM: Success\n\n    JM-&gt;&gt;M: pick_mold(\"A1\")\n    M-&gt;&gt;SM: Update payload state\n    M-&gt;&gt;H: Execute gripper\n\n    JM-&gt;&gt;SM: validated_move_to_scale()\n    SM-&gt;&gt;H: Execute movement\n\n    JM-&gt;&gt;M: place_mold_on_scale()\n    M-&gt;&gt;H: Execute gripper\n    M-&gt;&gt;SM: Update payload state\n\n    JM-&gt;&gt;SM: validated_fill_powder(50.0)\n    SM-&gt;&gt;S: Read weight\n    SM-&gt;&gt;H: Control trickler\n    SM-&gt;&gt;S: Read weight\n    Note over SM,S: Repeat until target reached\n\n    JM-&gt;&gt;M: pick_mold_from_scale()\n    JM-&gt;&gt;SM: validated_move_to_dispenser(0)\n    JM-&gt;&gt;SM: validated_retrieve_piston(0)\n    JM-&gt;&gt;SM: validated_move_to_mold_slot(\"A1\")\n    JM-&gt;&gt;M: place_mold(\"A1\")\n\n    JM--&gt;&gt;U: True (success)</code></pre>"},{"location":"concepts/architecture/#key-design-principles","title":"Key Design Principles","text":""},{"location":"concepts/architecture/#safety-through-validation","title":"Safety Through Validation","text":"<p>All movements must pass through the state machine validator. This prevents:</p> <ul> <li>Moving to unsafe positions</li> <li>Collisions between tools and labware</li> <li>Invalid state transitions</li> <li>Operating on wrong component</li> </ul>"},{"location":"concepts/architecture/#progressive-disclosure","title":"Progressive Disclosure","text":"<p>The architecture supports multiple levels of complexity:</p> <ul> <li>Simple: Use JubileeManager methods (most users)</li> <li>Advanced: Access state machine directly (power users)</li> <li>Expert: Access components and machine directly (developers)</li> </ul>"},{"location":"concepts/architecture/#state-tracking","title":"State Tracking","text":"<p>The system maintains comprehensive state:</p> <ul> <li>Physical position of motion platform</li> <li>Active tool and payload</li> <li>Component states (dispenser piston counts, etc.)</li> <li>Configuration data</li> </ul>"},{"location":"concepts/architecture/#fail-safe-defaults","title":"Fail-Safe Defaults","text":"<p>When operations fail:</p> <ul> <li>Clear error messages explain what went wrong</li> <li>System state remains consistent</li> <li>No silent failures</li> <li>Failed operations return False/ValidationResult</li> </ul>"},{"location":"concepts/architecture/#configuration-driven","title":"Configuration-Driven","text":"<p>Physical parameters are in configuration files, not code:</p> <ul> <li>Easy to adapt to different setups</li> <li>No recompilation needed</li> <li>Version control for configurations</li> <li>Validation of configuration data</li> </ul>"},{"location":"concepts/architecture/#component-interactions","title":"Component Interactions","text":""},{"location":"concepts/architecture/#jubileemanager-statemachine","title":"JubileeManager \u2194 StateMachine","text":"<ul> <li>JubileeManager owns the StateMachine</li> <li>All movements go through StateMachine validation</li> <li>JubileeManager coordinates multi-step operations</li> <li>StateMachine enforces single-step safety</li> </ul>"},{"location":"concepts/architecture/#manipulator-statemachine","title":"Manipulator \u2194 StateMachine","text":"<ul> <li>Manipulator updates payload state via StateMachine</li> <li>State machine validates movements based on payload</li> <li>Manipulator uses StateMachine for movements</li> </ul>"},{"location":"concepts/architecture/#configuration-all-components","title":"Configuration \u2194 All Components","text":"<ul> <li>All components read their configuration via ConfigLoader</li> <li>Positions, speeds, and parameters come from JSON</li> <li>Configuration is loaded once at startup</li> </ul>"},{"location":"concepts/architecture/#extending-the-system","title":"Extending the System","text":""},{"location":"concepts/architecture/#adding-new-operations","title":"Adding New Operations","text":"<p>To add a new high-level operation:</p> <ol> <li>Add method to <code>JubileeManager</code></li> <li>Break down into state machine operations</li> <li>Call <code>validated_*</code> methods on state machine</li> <li>Handle errors and return success/failure</li> </ol>"},{"location":"concepts/architecture/#adding-new-hardware","title":"Adding New Hardware","text":"<p>To add a new hardware component:</p> <ol> <li>Create new component class (like <code>PistonDispenser</code>)</li> <li>Add component to state machine context</li> <li>Add validation logic if needed</li> <li>Add configuration entries</li> <li>Add convenience methods to JubileeManager</li> </ol>"},{"location":"concepts/architecture/#adding-new-positions","title":"Adding New Positions","text":"<p>To add a new named position:</p> <ol> <li>Add entry to <code>motion_platform_positions.json</code></li> <li>Define allowed transitions</li> <li>Define constraints (tool required, payload restrictions)</li> <li>Add convenience method to JubileeManager if needed</li> </ol>"},{"location":"concepts/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/architecture/#movement-optimization","title":"Movement Optimization","text":"<ul> <li>State machine can batch movements when safe</li> <li>Configuration sets appropriate feed rates</li> <li>Direct paths when validated as safe</li> </ul>"},{"location":"concepts/architecture/#error-handling","title":"Error Handling","text":"<ul> <li>Validation happens before movement (fail fast)</li> <li>Clear error messages reduce debugging time</li> <li>State preserved on failure for recovery</li> </ul>"},{"location":"concepts/architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"concepts/architecture/#access-control","title":"Access Control","text":"<ul> <li>State machine prevents bypass of validation</li> <li>JubileeManager owns state machine exclusively</li> <li>Configuration files control physical limits</li> </ul>"},{"location":"concepts/architecture/#safety-zones","title":"Safety Zones","text":"<ul> <li>Configuration defines safe operating areas</li> <li>State machine enforces these boundaries</li> <li>Emergency stop accessible via hardware</li> </ul>"},{"location":"concepts/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Review the Glossary for terminology</li> <li>Explore JubileeManager API</li> <li>Understand State Machine Details</li> </ul>"},{"location":"concepts/glossary/","title":"Glossary","text":"<p>This glossary defines key terms used throughout the Jubilee Powder system.</p>"},{"location":"concepts/glossary/#general-terms","title":"General Terms","text":""},{"location":"concepts/glossary/#jubilee","title":"Jubilee","text":"<p>A tool-changing CNC motion platform developed by the Machine Agency. The base hardware for this automation system.</p>"},{"location":"concepts/glossary/#motion-platform","title":"Motion Platform","text":"<p>The physical CNC (Computer Numerical Control) system that provides X, Y, Z positioning and tool changing capabilities.</p>"},{"location":"concepts/glossary/#deck","title":"Deck","text":"<p>The working surface of the Jubilee where labware (molds, dispensers, scale, etc.) is positioned. The deck layout is defined in configuration files.</p>"},{"location":"concepts/glossary/#labware","title":"Labware","text":"<p>Physical items placed on the deck, such as well plates, dispensers, scales, and other equipment.</p>"},{"location":"concepts/glossary/#core-components","title":"Core Components","text":""},{"location":"concepts/glossary/#jubileemanager","title":"JubileeManager","text":"<p>The primary high-level interface for controlling the Jubilee system. Coordinates operations between multiple hardware components and provides simplified APIs for common tasks.</p> <p>When to use: For all standard operations. This should be your first choice for interacting with the system.</p>"},{"location":"concepts/glossary/#motionplatformstatemachine","title":"MotionPlatformStateMachine","text":"<p>A state machine that validates and executes all movements. Ensures safety by tracking system state and preventing invalid operations.</p> <p>When to use: For advanced control when JubileeManager doesn't provide the specific operation you need.</p>"},{"location":"concepts/glossary/#manipulator","title":"Manipulator","text":"<p>A custom toolhead with a gripper and vertical axis (V-axis). Used for picking up and placing molds and other objects.</p> <p>Key features: - Gripper for holding objects - Vertical axis for precise height control - Integrated with state machine for validated movements</p>"},{"location":"concepts/glossary/#pistondispenser","title":"PistonDispenser","text":"<p>A container that holds and dispenses cylindrical pistons. Tracks the number of available pistons and provides them one at a time.</p> <p>Key features: - Holds multiple pistons in a stack - Dispenses from the top of the stack - Tracks available piston count</p>"},{"location":"concepts/glossary/#scale","title":"Scale","text":"<p>A precision balance for weighing objects. Connected via USB serial connection.</p> <p>Capabilities: - Stable weight reading (waits for stability) - Unstable weight reading (immediate) - High precision measurements</p>"},{"location":"concepts/glossary/#state-machine-concepts","title":"State Machine Concepts","text":""},{"location":"concepts/glossary/#state","title":"State","text":"<p>The current condition of the system, including: - Physical position of the motion platform - Which tool is active (picked up) - What the manipulator is holding (payload)</p>"},{"location":"concepts/glossary/#validation","title":"Validation","text":"<p>The process of checking whether a requested operation is safe and valid given the current state.</p> <p>Validation checks: - Is the current position correct for this operation? - Is the right tool picked up? - Is the payload state compatible? - Are constraints satisfied?</p>"},{"location":"concepts/glossary/#named-position","title":"Named Position","text":"<p>A predefined location on the deck with a specific name (e.g., \"global_ready\", \"scale_ready\"). Named positions are defined in the configuration file.</p> <p>Examples: - <code>global_ready</code>: Safe position away from all labware - <code>scale_ready</code>: Position to access the scale - <code>mold_slot_A1</code>: Position to access well A1</p>"},{"location":"concepts/glossary/#transition","title":"Transition","text":"<p>A validated movement from one named position to another. The state machine defines which transitions are allowed.</p>"},{"location":"concepts/glossary/#context","title":"Context","text":"<p>The state machine's internal representation of the current system state. Includes: - Current position - Active tool - Payload state - Reference to hardware components</p>"},{"location":"concepts/glossary/#payload-states","title":"Payload States","text":""},{"location":"concepts/glossary/#empty","title":"Empty","text":"<p>The manipulator is not holding any object. This is the default state after homing or after placing an object.</p>"},{"location":"concepts/glossary/#mold","title":"Mold","text":"<p>The manipulator is holding a mold (well plate or container). The mold does not contain a piston.</p>"},{"location":"concepts/glossary/#mold-with-piston","title":"Mold with Piston","text":"<p>The manipulator is holding a mold that contains a piston. This affects weight and handling.</p>"},{"location":"concepts/glossary/#tool-concepts","title":"Tool Concepts","text":""},{"location":"concepts/glossary/#tool","title":"Tool","text":"<p>An interchangeable attachment that the Jubilee can pick up and put down. In this system, the primary tool is the Manipulator.</p>"},{"location":"concepts/glossary/#tool-pickup","title":"Tool Pickup","text":"<p>The process of mechanically engaging with a tool at its parking position and locking it to the carriage.</p>"},{"location":"concepts/glossary/#tool-parking","title":"Tool Parking","text":"<p>The process of placing a tool back at its designated parking position and releasing it.</p>"},{"location":"concepts/glossary/#active-tool","title":"Active Tool","text":"<p>The tool currently picked up and ready for use. Only one tool can be active at a time.</p>"},{"location":"concepts/glossary/#movement-concepts","title":"Movement Concepts","text":""},{"location":"concepts/glossary/#homing","title":"Homing","text":"<p>The process of moving axes to their reference positions (endstops) to establish a coordinate system. Must be done before any precision operations.</p> <p>Types: - Home All: Homes X, Y, Z, and U axes - Home Manipulator: Homes the manipulator's V axis - Rehome: Re-establishes reference after an error</p>"},{"location":"concepts/glossary/#feed-rate","title":"Feed Rate","text":"<p>The speed at which the motion platform moves. Can be set to different values for different operations.</p> <p>Common values: - SLOW: For precise operations - MEDIUM: For normal operations (default) - FAST: For rapid positioning</p>"},{"location":"concepts/glossary/#safe-zone","title":"Safe Zone","text":"<p>An area of the deck where movement is known to be safe. The state machine uses safe zones to prevent collisions.</p>"},{"location":"concepts/glossary/#configuration-terms","title":"Configuration Terms","text":""},{"location":"concepts/glossary/#configuration-file","title":"Configuration File","text":"<p>A JSON file that defines system parameters, positions, and constraints. Changes to configuration do not require code changes.</p> <p>Key configuration files: - <code>motion_platform_positions.json</code>: Defines positions and transitions - <code>system_config.json</code>: System-level settings - <code>mold_labware.json</code>: Deck layout and labware - <code>weight_well_deck.json</code>: Well-specific parameters</p>"},{"location":"concepts/glossary/#deck-layout","title":"Deck Layout","text":"<p>The arrangement of labware on the Jubilee deck, defined in configuration files. Includes positions and dimensions of all items.</p>"},{"location":"concepts/glossary/#system-config","title":"System Config","text":"<p>Global system parameters such as: - Duet controller IP address - Serial port assignments - Default feed rates - Tool configurations</p>"},{"location":"concepts/glossary/#operation-terms","title":"Operation Terms","text":""},{"location":"concepts/glossary/#dispense-operation","title":"Dispense Operation","text":"<p>A complete workflow that: 1. Picks up a mold from a well 2. Moves to the scale 3. Fills the mold with powder to a target weight 4. Retrieves a piston from a dispenser 5. Returns the mold to the well</p>"},{"location":"concepts/glossary/#trickler","title":"Trickler","text":"<p>A powder dispensing mechanism used to add material to a mold on the scale. Controlled to achieve precise target weights.</p>"},{"location":"concepts/glossary/#well-id","title":"Well ID","text":"<p>A unique identifier for a position in a well plate (e.g., \"A1\", \"B2\"). Used to reference specific locations in the deck layout.</p>"},{"location":"concepts/glossary/#target-weight","title":"Target Weight","text":"<p>The desired weight of material to dispense into a mold, measured in grams.</p>"},{"location":"concepts/glossary/#error-and-validation-terms","title":"Error and Validation Terms","text":""},{"location":"concepts/glossary/#validation-result","title":"Validation Result","text":"<p>The result of a validation check, indicating whether an operation is allowed and providing a reason if not.</p> <p>Fields: - <code>valid</code>: Boolean indicating if operation is allowed - <code>reason</code>: String explaining why operation was rejected (if invalid)</p>"},{"location":"concepts/glossary/#tool-state-error","title":"Tool State Error","text":"<p>An exception raised when an operation is attempted with the wrong tool state (e.g., tool not picked up, wrong tool active).</p>"},{"location":"concepts/glossary/#movement-constraint","title":"Movement Constraint","text":"<p>A rule that limits when or how a movement can be performed. Examples: - \"Must have manipulator tool picked up\" - \"Cannot move with mold_with_piston payload\" - \"Must be at global_ready position first\"</p>"},{"location":"concepts/glossary/#hardware-terms","title":"Hardware Terms","text":""},{"location":"concepts/glossary/#duet-controller","title":"Duet Controller","text":"<p>The controller board that runs the Jubilee machine. Provides G-code interpretation and motor control.</p>"},{"location":"concepts/glossary/#g-code","title":"G-code","text":"<p>The programming language used to control CNC machines. The Duet controller interprets G-code commands.</p>"},{"location":"concepts/glossary/#endstop","title":"Endstop","text":"<p>A sensor that detects when an axis has reached its reference position. Used during homing.</p>"},{"location":"concepts/glossary/#serial-port","title":"Serial Port","text":"<p>A communication interface used to connect to the scale. Typically appears as <code>/dev/ttyUSB0</code> on Linux.</p>"},{"location":"concepts/glossary/#ip-address","title":"IP Address","text":"<p>The network address of the Jubilee's Duet controller. Used to establish network communication.</p>"},{"location":"concepts/glossary/#software-development-terms","title":"Software Development Terms","text":""},{"location":"concepts/glossary/#type-hints","title":"Type Hints","text":"<p>Python annotations that specify the expected types of function parameters and return values. Used throughout the codebase for better code quality.</p>"},{"location":"concepts/glossary/#docstring","title":"Docstring","text":"<p>Documentation embedded in Python code that describes what a function, class, or module does. This project uses Google-style docstrings.</p>"},{"location":"concepts/glossary/#google-docstring-style","title":"Google Docstring Style","text":"<p>A specific format for writing docstrings that includes sections for arguments, returns, raises, examples, etc.</p>"},{"location":"concepts/glossary/#see-also","title":"See Also","text":"<ul> <li>Architecture Overview - Understand how these components work together</li> <li>Quick Start Guide - See these terms in context</li> <li>API Reference - Detailed documentation of all components</li> </ul>"},{"location":"getting-started/overview/","title":"Overview","text":""},{"location":"getting-started/overview/#what-is-jubilee-powder","title":"What is Jubilee Powder?","text":"<p>Jubilee Powder is a comprehensive software system for controlling the Jubilee Motion Platform to automate powder dispensing and handling tasks. It provides a Python API for coordinating complex powder dispensing operations involving multiple hardware components.</p>"},{"location":"getting-started/overview/#core-components","title":"Core Components","text":""},{"location":"getting-started/overview/#hardware","title":"Hardware","text":"<p>The system integrates with several hardware components:</p> <ul> <li>Jubilee Motion Platform: A tool-changing CNC motion system</li> <li>Precision Scale: For weighing materials with high accuracy</li> <li>Piston Dispensers: For storing and dispensing cylindrical pistons/tools</li> <li>Manipulator Tool: A custom toolhead with gripper and vertical axis</li> </ul>"},{"location":"getting-started/overview/#software-layers","title":"Software Layers","text":"<p>The software is organized in layers from high-level to low-level:</p> <ol> <li>JubileeManager (Top Layer)</li> <li>Highest-level API for common operations</li> <li>Coordinates multiple components</li> <li> <p>Error handling and recovery</p> </li> <li> <p>MotionPlatformStateMachine (Middle Layer)</p> </li> <li>Validates all movements for safety</li> <li>Manages system state</li> <li> <p>Enforces movement constraints</p> </li> <li> <p>Hardware Drivers (Bottom Layer)</p> </li> <li>Direct hardware communication</li> <li>Low-level control primitives</li> </ol>"},{"location":"getting-started/overview/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/overview/#state-machine-validation","title":"State Machine Validation","text":"<p>All movements are validated through a state machine that:</p> <ul> <li>Tracks the current position and tool state</li> <li>Validates requested movements are safe</li> <li>Prevents invalid state transitions</li> <li>Ensures proper sequencing of operations</li> </ul>"},{"location":"getting-started/overview/#tool-management","title":"Tool Management","text":"<p>The Jubilee uses a tool-changing system where:</p> <ul> <li>Tools are picked up and parked at specific positions</li> <li>Only one tool can be active at a time</li> <li>Tools must be at specific positions for certain operations</li> </ul>"},{"location":"getting-started/overview/#payload-tracking","title":"Payload Tracking","text":"<p>The system tracks what the manipulator is holding:</p> <ul> <li><code>empty</code>: No mold held</li> <li><code>mold</code>: Holding a mold</li> <li><code>mold_with_piston</code>: Holding a mold that contains a piston</li> </ul> <p>This enables safe movement validation based on current load.</p>"},{"location":"getting-started/overview/#design-philosophy","title":"Design Philosophy","text":""},{"location":"getting-started/overview/#safety-first","title":"Safety First","text":"<ul> <li>All movements are validated before execution</li> <li>State machine prevents unsafe operations</li> <li>Clear error messages for invalid requests</li> </ul>"},{"location":"getting-started/overview/#ease-of-use","title":"Ease of Use","text":"<ul> <li>High-level API for common operations</li> <li>Sensible defaults</li> <li>Progressive disclosure (simple things simple, complex things possible)</li> </ul>"},{"location":"getting-started/overview/#flexibility","title":"Flexibility","text":"<ul> <li>JSON-based configuration</li> <li>Extensible architecture</li> <li>Multiple access levels (high-level to low-level)</li> </ul>"},{"location":"getting-started/overview/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/overview/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Jubilee Motion Platform with Duet3D controller</li> <li>USB connection to precision scale</li> <li>Network connection to Jubilee controller</li> <li>Sufficient workspace for deck layout</li> </ul>"},{"location":"getting-started/overview/#software-requirements","title":"Software Requirements","text":"<ul> <li>Python 3.8 or later</li> <li>Linux-based operating system (for hardware integration)</li> <li>Dependencies listed in <code>requirements.txt</code></li> </ul>"},{"location":"getting-started/overview/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/bennett-lahn/jubilee-powder.git\ncd jubilee-powder\n</code></pre></p> </li> <li> <p>Create a virtual environment: <pre><code>python -m venv jubilee-env\nsource jubilee-env/bin/activate  # On Linux/Mac\n# or\njubilee-env\\Scripts\\activate  # On Windows\n</code></pre></p> </li> <li> <p>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Configure your system:</p> </li> <li>Edit configuration files in <code>jubilee_api_config/</code></li> <li>Set Jubilee IP address</li> <li>Configure deck layout</li> <li>Set up tool positions</li> </ol>"},{"location":"getting-started/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start Guide for your first program</li> <li>Learn about key concepts in the Architecture Guide</li> <li>Explore How-To Guides for common tasks</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will walk you through creating your first Jubilee powder dispensing script.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>[ ] Jubilee Powder installed (see Overview)</li> <li>[ ] Jubilee machine powered on and network-accessible</li> <li>[ ] Scale connected via USB</li> <li>[ ] Configuration files set up in <code>jubilee_api_config/</code></li> </ul>"},{"location":"getting-started/quickstart/#your-first-script","title":"Your First Script","text":""},{"location":"getting-started/quickstart/#step-1-import-jubileemanager","title":"Step 1: Import JubileeManager","text":"<pre><code>from src.JubileeManager import JubileeManager\n</code></pre> <p>The <code>JubileeManager</code> class is your primary interface to the Jubilee system.</p>"},{"location":"getting-started/quickstart/#step-2-create-manager-instance","title":"Step 2: Create Manager Instance","text":"<pre><code>manager = JubileeManager(\n    num_piston_dispensers=2,       # Number of piston dispensers\n    num_pistons_per_dispenser=10   # Pistons per dispenser\n)\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-connect-to-hardware","title":"Step 3: Connect to Hardware","text":"<pre><code>from pathlib import Path\n\n# Connect to the system\n# Option 1: Use default (automatically finds config in project root)\nconnected = manager.connect(\n    machine_address=\"192.168.1.100\",  # Your Jubilee IP address\n    scale_port=\"/dev/ttyUSB0\"         # Scale serial port\n    # state_machine_config defaults to project_root/jubilee_api_config/motion_platform_positions.json\n)\n\n# Option 2: Specify custom path (absolute or relative to project root)\n# project_root = Path(__file__).parent.parent\n# connected = manager.connect(\n#     machine_address=\"192.168.1.100\",\n#     scale_port=\"/dev/ttyUSB0\",\n#     state_machine_config=str(project_root / \"jubilee_api_config\" / \"motion_platform_positions.json\")\n# )\n\nif not connected:\n    print(\"Failed to connect!\")\n    exit(1)\n\nprint(\"Connected successfully!\")\n</code></pre> <p>Note</p> <p>The <code>connect()</code> method will automatically:</p> <ul> <li>Connect to the Jubilee machine</li> <li>Connect to the scale</li> <li>Initialize the state machine</li> <li>Home all axes</li> <li>Pick up the manipulator tool</li> <li>Home the manipulator axis</li> </ul>"},{"location":"getting-started/quickstart/#step-4-read-scale-weight","title":"Step 4: Read Scale Weight","text":"<pre><code># Get current weight from scale\nweight = manager.get_weight_stable()\nprint(f\"Current weight: {weight}g\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-perform-operations","title":"Step 5: Perform Operations","text":"<pre><code># Dispense to a well with target weight\nsuccess = manager.dispense_to_well(\n    well_id=\"A1\",           # Well identifier from your deck config\n    target_weight=50.0      # Target weight in grams\n)\n\nif success:\n    print(\"Dispense operation completed successfully!\")\nelse:\n    print(\"Dispense operation failed!\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-clean-up","title":"Step 6: Clean Up","text":"<pre><code># Always disconnect when done\nmanager.disconnect()\nprint(\"Disconnected from hardware\")\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's the complete script:</p> <pre><code>from src.JubileeManager import JubileeManager\n\ndef main():\n    # Create manager\n    manager = JubileeManager(\n        num_piston_dispensers=2,\n        num_pistons_per_dispenser=10\n    )\n\n    # Connect\n    if not manager.connect(\n        machine_address=\"192.168.1.100\",\n        scale_port=\"/dev/ttyUSB0\"\n    ):\n        print(\"Failed to connect!\")\n        return\n\n    try:\n        # Read weight\n        initial_weight = manager.get_weight_stable()\n        print(f\"Initial weight: {initial_weight}g\")\n\n        # Dispense operation\n        success = manager.dispense_to_well(\n            well_id=\"A1\",\n            target_weight=50.0\n        )\n\n        if success:\n            print(\"Operation completed!\")\n        else:\n            print(\"Operation failed!\")\n\n    finally:\n        # Always disconnect\n        manager.disconnect()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-what-happened","title":"Understanding What Happened","text":"<p>When you run this script:</p> <ol> <li>Connection Phase:</li> <li>Connects to Jubilee controller via network</li> <li>Connects to scale via USB serial</li> <li>Loads configuration from JSON files</li> <li>Homes all machine axes (X, Y, Z, U)</li> <li>Picks up the manipulator tool</li> <li> <p>Homes the manipulator's vertical axis (V)</p> </li> <li> <p>Operation Phase:</p> </li> <li>Moves to the specified well location</li> <li>Picks up the mold from the well</li> <li>Moves to the scale</li> <li>Places mold on scale</li> <li>Fills powder to target weight</li> <li>Picks up mold from scale</li> <li>Gets a piston from dispenser</li> <li> <p>Returns mold to well</p> </li> <li> <p>Cleanup Phase:</p> </li> <li>Disconnects from all hardware</li> <li>Releases resources</li> </ol>"},{"location":"getting-started/quickstart/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quickstart/#connection-fails","title":"Connection Fails","text":"<p>If <code>manager.connect()</code> returns <code>False</code>:</p> <ul> <li>Check Jubilee IP: Verify the IP address is correct</li> <li>Check Network: Ensure your computer can reach the Jubilee (try <code>ping 192.168.1.100</code>)</li> <li>Check Scale Port: Verify the scale is connected (<code>ls /dev/ttyUSB*</code> on Linux)</li> <li>Check Permissions: Ensure you have permission to access the serial port</li> </ul>"},{"location":"getting-started/quickstart/#homing-fails","title":"Homing Fails","text":"<p>If homing fails during connection:</p> <ul> <li>Check Endstops: Ensure all endstops are functioning</li> <li>Check Tool State: Verify no tool is already picked up</li> <li>Check Deck Clear: Ensure the deck is clear of obstructions</li> </ul>"},{"location":"getting-started/quickstart/#dispense-operation-fails","title":"Dispense Operation Fails","text":"<p>If <code>dispense_to_well()</code> returns <code>False</code>:</p> <ul> <li>Check Well ID: Verify the well ID exists in your deck configuration</li> <li>Check Dispenser: Ensure the dispenser has available pistons</li> <li>Check Scale: Verify the scale is responding</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working script:</p> <ul> <li>Learn about system architecture</li> <li>Explore how-to guides for specific tasks</li> <li>Review the JubileeManager API reference</li> <li>Understand the state machine for advanced control</li> </ul>"},{"location":"getting-started/quickstart/#tips","title":"Tips","text":"<p>Use Try-Finally</p> <p>Always use <code>try-finally</code> blocks to ensure <code>disconnect()</code> is called even if an error occurs.</p> <p>Check Return Values</p> <p>Most JubileeManager methods return <code>True/False</code> to indicate success. Always check these values.</p> <p>Start Simple</p> <p>Begin with simple operations like reading the scale before attempting complex multi-step operations.</p> <p>Hardware Safety</p> <p>Always monitor the first run of any new script. Be ready to press the emergency stop if needed.</p>"},{"location":"how-to/configuration/","title":"Configuration Guide","text":"<p>This guide explains how to configure the Jubilee Powder system for your specific setup.</p>"},{"location":"how-to/configuration/#overview","title":"Overview","text":"<p>The Jubilee Automation system uses JSON configuration files to define:</p> <ul> <li>Physical positions and movements</li> <li>Deck layout and labware</li> <li>System parameters and hardware settings</li> <li>Operational constraints and safety zones</li> </ul> <p>All configuration files are located in the <code>jubilee_api_config/</code> directory.</p>"},{"location":"how-to/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"how-to/configuration/#motion_platform_positionsjson","title":"motion_platform_positions.json","text":"<p>Defines named positions, their coordinates, and valid transitions.</p> <p>Purpose: State machine position definitions and movement validation</p> <p>Location: <code>jubilee_api_config/motion_platform_positions.json</code></p>"},{"location":"how-to/configuration/#structure","title":"Structure","text":"<pre><code>{\n  \"positions\": {\n    \"position_name\": {\n      \"coordinates\": {\n        \"x\": 100.0,\n        \"y\": 150.0,\n        \"z\": 200.0,\n        \"safe_z\": 250.0\n      },\n      \"description\": \"Human-readable description\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"empty\", \"mold\", \"mold_with_piston\"],\n      \"constraints\": {\n        \"min_z\": 50.0,\n        \"max_z\": 300.0\n      }\n    }\n  },\n  \"transitions\": {\n    \"position_name\": {\n      \"to\": [\"other_position\", \"another_position\"],\n      \"requires_payload\": null\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#key-fields","title":"Key Fields","text":"<ul> <li><code>coordinates</code>: Physical X, Y, Z positions in millimeters</li> <li><code>safe_z</code>: Height for safe travel over obstacles</li> <li><code>requires_tool</code>: Tool that must be active (or <code>null</code> for any/none)</li> <li><code>allowed_payloads</code>: List of valid payload states for this position</li> <li><code>transitions.to</code>: List of positions directly reachable from here</li> </ul>"},{"location":"how-to/configuration/#example-adding-a-new-position","title":"Example: Adding a New Position","text":"<pre><code>{\n  \"positions\": {\n    \"my_custom_position\": {\n      \"coordinates\": {\n        \"x\": 120.0,\n        \"y\": 180.0,\n        \"z\": 100.0,\n        \"safe_z\": 200.0\n      },\n      \"description\": \"Custom position for special labware\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"empty\"]\n    }\n  },\n  \"transitions\": {\n    \"global_ready\": {\n      \"to\": [\"my_custom_position\"]\n    },\n    \"my_custom_position\": {\n      \"to\": [\"global_ready\"]\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#system_configjson","title":"system_config.json","text":"<p>Defines system-level parameters and hardware settings.</p> <p>Purpose: Global system configuration</p> <p>Location: <code>jubilee_api_config/system_config.json</code></p>"},{"location":"how-to/configuration/#structure_1","title":"Structure","text":"<pre><code>{\n  \"system\": {\n    \"duet_ip\": \"192.168.1.100\",\n    \"scale_port\": \"/dev/ttyUSB0\",\n    \"default_feedrate\": \"MEDIUM\"\n  },\n  \"tools\": {\n    \"manipulator\": {\n      \"index\": 0,\n      \"park_position\": {\"x\": 0, \"y\": 0, \"z\": 100},\n      \"v_axis_offset\": 50.0,\n      \"gripper_config\": {\n        \"open_position\": 5.0,\n        \"close_position\": 0.0,\n        \"grip_force\": 10.0\n      }\n    }\n  },\n  \"safety\": {\n    \"max_speed\": 10000,\n    \"acceleration\": 500,\n    \"work_envelope\": {\n      \"x_min\": 0, \"x_max\": 300,\n      \"y_min\": 0, \"y_max\": 300,\n      \"z_min\": 0, \"z_max\": 300\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#key-sections","title":"Key Sections","text":"<ul> <li><code>system</code>: Global system settings (IPs, ports, defaults)</li> <li><code>tools</code>: Tool-specific configurations</li> <li><code>safety</code>: Safety parameters and limits</li> </ul>"},{"location":"how-to/configuration/#mold_labwarejson","title":"mold_labware.json","text":"<p>Defines deck layout, labware positions, and well configurations.</p> <p>Purpose: Physical deck layout and labware definitions</p> <p>Location: <code>jubilee_api_config/mold_labware.json</code></p>"},{"location":"how-to/configuration/#structure_2","title":"Structure","text":"<pre><code>{\n  \"deck\": {\n    \"name\": \"Main Deck\",\n    \"dimensions\": {\n      \"width\": 300,\n      \"height\": 300\n    },\n    \"labware\": {\n      \"well_plate_1\": {\n        \"type\": \"well_plate\",\n        \"name\": \"24-Well Plate\",\n        \"rows\": 4,\n        \"columns\": 6,\n        \"well_spacing_x\": 20.0,\n        \"well_spacing_y\": 20.0,\n        \"origin\": {\"x\": 50, \"y\": 50, \"z\": 10},\n        \"wells\": {\n          \"A1\": {\n            \"position\": {\"x\": 50, \"y\": 50, \"z\": 10},\n            \"ready_pos\": \"mold_slot_A1\",\n            \"capacity_ml\": 10.0,\n            \"description\": \"Top-left well\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#key-fields_1","title":"Key Fields","text":"<ul> <li><code>labware</code>: Dictionary of all labware on the deck</li> <li><code>wells</code>: Individual well definitions with positions</li> <li><code>ready_pos</code>: Links to named position in motion_platform_positions.json</li> </ul>"},{"location":"how-to/configuration/#weight_well_deckjson","title":"weight_well_deck.json","text":"<p>Defines well-specific weight parameters and tolerances.</p> <p>Purpose: Weight-related configuration for dispense operations</p> <p>Location: <code>jubilee_api_config/weight_well_deck.json</code></p>"},{"location":"how-to/configuration/#structure_3","title":"Structure","text":"<pre><code>{\n  \"weight_config\": {\n    \"A1\": {\n      \"tare_weight\": 5.2,\n      \"target_tolerance\": 0.1,\n      \"max_fill_time\": 120,\n      \"trickler_speed\": \"medium\"\n    },\n    \"A2\": {\n      \"tare_weight\": 5.3,\n      \"target_tolerance\": 0.05,\n      \"max_fill_time\": 180,\n      \"trickler_speed\": \"slow\"\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#key-fields_2","title":"Key Fields","text":"<ul> <li><code>tare_weight</code>: Empty mold weight in grams</li> <li><code>target_tolerance</code>: Acceptable deviation from target in grams</li> <li><code>max_fill_time</code>: Maximum seconds to attempt filling</li> <li><code>trickler_speed</code>: Powder dispense rate</li> </ul>"},{"location":"how-to/configuration/#common-configuration-tasks","title":"Common Configuration Tasks","text":""},{"location":"how-to/configuration/#task-1-change-jubilee-ip-address","title":"Task 1: Change Jubilee IP Address","text":"<p>Edit <code>system_config.json</code>:</p> <pre><code>{\n  \"system\": {\n    \"duet_ip\": \"192.168.1.200\"\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#task-2-add-a-new-well-plate","title":"Task 2: Add a New Well Plate","text":"<ol> <li>Add labware definition to <code>mold_labware.json</code>:</li> </ol> <pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"my_new_plate\": {\n        \"type\": \"well_plate\",\n        \"name\": \"12-Well Plate\",\n        \"rows\": 3,\n        \"columns\": 4,\n        \"well_spacing_x\": 25.0,\n        \"well_spacing_y\": 25.0,\n        \"origin\": {\"x\": 100, \"y\": 100, \"z\": 15},\n        \"wells\": {}\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Generate well positions (use a script or manually):</li> </ol> <pre><code>import json\n\nrows = ['A', 'B', 'C']\ncols = range(1, 5)  # 1-4\norigin_x, origin_y = 100, 100\nspacing_x, spacing_y = 25, 25\n\nwells = {}\nfor i, row in enumerate(rows):\n    for j, col in enumerate(cols):\n        well_id = f\"{row}{col}\"\n        wells[well_id] = {\n            \"position\": {\n                \"x\": origin_x + (j * spacing_x),\n                \"y\": origin_y + (i * spacing_y),\n                \"z\": 15\n            },\n            \"ready_pos\": f\"mold_slot_{well_id}\",\n            \"capacity_ml\": 5.0\n        }\n\nprint(json.dumps(wells, indent=2))\n</code></pre> <ol> <li> <p>Add positions to <code>motion_platform_positions.json</code> for each well</p> </li> <li> <p>Add weight config to <code>weight_well_deck.json</code> if using for dispense</p> </li> </ol>"},{"location":"how-to/configuration/#task-3-adjust-movement-speed","title":"Task 3: Adjust Movement Speed","text":"<p>Edit <code>system_config.json</code>:</p> <pre><code>{\n  \"system\": {\n    \"default_feedrate\": \"FAST\"\n  }\n}\n</code></pre> <p>Or in your code:</p> <pre><code>from jubilee_api_config.constants import FeedRate\n\nmanager = JubileeManager(\n    num_piston_dispensers=2,\n    num_pistons_per_dispenser=10,\n    feedrate=FeedRate.FAST\n)\n</code></pre>"},{"location":"how-to/configuration/#task-4-configure-piston-dispensers","title":"Task 4: Configure Piston Dispensers","text":"<p>Add dispenser configuration to <code>mold_labware.json</code>:</p> <pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"piston_dispenser_1\": {\n        \"type\": \"piston_dispenser\",\n        \"name\": \"Dispenser 1\",\n        \"position\": {\"x\": 200, \"y\": 50, \"z\": 20},\n        \"ready_pos\": \"dispenser_0_ready\",\n        \"capacity\": 20,\n        \"piston_height\": 50.0,\n        \"piston_diameter\": 10.0\n      }\n    }\n  }\n}\n</code></pre> <p>Add corresponding position to <code>motion_platform_positions.json</code>:</p> <pre><code>{\n  \"positions\": {\n    \"dispenser_0_ready\": {\n      \"coordinates\": {\"x\": 200, \"y\": 50, \"z\": 100, \"safe_z\": 150},\n      \"description\": \"Ready position for piston dispenser 0\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"mold_with_piston\"]\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"how-to/configuration/#1-use-version-control","title":"1. Use Version Control","text":"<p>Always commit configuration changes to git:</p> <pre><code>git add jubilee_api_config/\ngit commit -m \"Add new well plate configuration\"\n</code></pre>"},{"location":"how-to/configuration/#2-keep-backups","title":"2. Keep Backups","text":"<p>Before making major changes:</p> <pre><code>cp -r jubilee_api_config/ jubilee_api_config_backup_$(date +%Y%m%d)/\n</code></pre>"},{"location":"how-to/configuration/#3-validate-configurations","title":"3. Validate Configurations","text":"<p>Create a validation script:</p> <pre><code>import json\nfrom pathlib import Path\n\ndef validate_config():\n    \"\"\"Validate all configuration files.\"\"\"\n    config_dir = Path(\"jubilee_api_config\")\n\n    # Check all required files exist\n    required_files = [\n        \"motion_platform_positions.json\",\n        \"system_config.json\",\n        \"mold_labware.json\"\n    ]\n\n    for file in required_files:\n        path = config_dir / file\n        if not path.exists():\n            print(f\"\u274c Missing: {file}\")\n            return False\n\n        # Validate JSON syntax\n        try:\n            with open(path) as f:\n                json.load(f)\n            print(f\"\u2705 Valid: {file}\")\n        except json.JSONDecodeError as e:\n            print(f\"\u274c Invalid JSON in {file}: {e}\")\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    if validate_config():\n        print(\"\\n\u2705 All configurations valid!\")\n    else:\n        print(\"\\n\u274c Configuration validation failed!\")\n</code></pre>"},{"location":"how-to/configuration/#4-document-custom-values","title":"4. Document Custom Values","text":"<p>Add comments in JSON (non-standard but helpful):</p> <pre><code>{\n  \"_comment\": \"Custom configuration for 24-well plate setup\",\n  \"deck\": {\n    \"labware\": {}\n  }\n}\n</code></pre> <p>Or maintain a separate README:</p> <pre><code># Configuration Notes\n\n## Well Plate Layout\n- Origin measured from front-left corner of deck\n- Z=10mm is the pickup height\n- safe_z=150mm clears all obstacles\n\n## Last Updated\n2025-01-06: Added new dispenser position\n</code></pre>"},{"location":"how-to/configuration/#5-test-after-changes","title":"5. Test After Changes","text":"<p>Always test configuration changes:</p> <pre><code># Test script\nfrom src.JubileeManager import JubileeManager\n\nmanager = JubileeManager()\nif manager.connect():\n    print(\"\u2705 Connection successful with new config\")\n    manager.disconnect()\nelse:\n    print(\"\u274c Connection failed - check configuration\")\n</code></pre>"},{"location":"how-to/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"how-to/configuration/#configuration-not-loading","title":"Configuration Not Loading","text":"<p>Symptom: \"Config file not found\" error</p> <p>Solutions: - Check file paths are correct - Verify files are in <code>jubilee_api_config/</code> directory - Check file permissions</p>"},{"location":"how-to/configuration/#invalid-json-syntax","title":"Invalid JSON Syntax","text":"<p>Symptom: <code>JSONDecodeError</code> when loading</p> <p>Solutions: - Use a JSON validator (jsonlint.com) - Check for missing commas, braces, quotes - Ensure no trailing commas (not valid in JSON)</p>"},{"location":"how-to/configuration/#position-not-found","title":"Position Not Found","text":"<p>Symptom: \"Position 'X' not found in state machine\"</p> <p>Solutions: - Verify position is defined in <code>motion_platform_positions.json</code> - Check spelling and case sensitivity - Ensure <code>ready_pos</code> in labware matches position name</p>"},{"location":"how-to/configuration/#transition-validation-failed","title":"Transition Validation Failed","text":"<p>Symptom: \"Cannot transition from A to B\"</p> <p>Solutions: - Check that transition is defined in <code>transitions</code> section - Verify transitions are bidirectional if needed - Add intermediate positions if direct transition not safe</p>"},{"location":"how-to/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Run operations on your configured setup</li> <li>Use Web UI to test positions</li> <li>Review API reference for configuration usage</li> </ul>"},{"location":"how-to/results/","title":"Interpreting Results","text":"<p>This guide explains how to interpret and analyze results from Jubilee powder dispensing operations.</p>"},{"location":"how-to/results/#overview","title":"Overview","text":"<p>After running dispense operations or other automated tasks, you'll have various types of data to analyze:</p> <ul> <li>Weight measurements</li> <li>Success/failure status</li> <li>Timing information</li> <li>Error logs</li> </ul> <p>Understanding these results helps you: - Verify operation quality - Identify systematic issues - Optimize parameters - Troubleshoot problems</p>"},{"location":"how-to/results/#result-data-structures","title":"Result Data Structures","text":""},{"location":"how-to/results/#dispense-operation-results","title":"Dispense Operation Results","text":"<p>When you run a dispense operation, typical result data looks like:</p> <pre><code>{\n  \"well_id\": \"A1\",\n  \"success\": true,\n  \"target_weight\": 50.0,\n  \"final_weight\": 50.02,\n  \"error\": 0.02,\n  \"percent_error\": 0.04,\n  \"duration_seconds\": 145.3,\n  \"timestamp\": \"2025-01-06T10:30:45\",\n  \"iterations\": 12,\n  \"notes\": null\n}\n</code></pre>"},{"location":"how-to/results/#key-fields","title":"Key Fields","text":"<ul> <li><code>success</code>: Boolean indicating if operation completed</li> <li><code>target_weight</code>: Requested weight in grams</li> <li><code>final_weight</code>: Actual measured weight in grams</li> <li><code>error</code>: Difference between target and actual (final - target)</li> <li><code>percent_error</code>: Error as percentage of target</li> <li><code>duration_seconds</code>: Time taken for operation</li> <li><code>iterations</code>: Number of fill cycles (for powder dispensing)</li> </ul>"},{"location":"how-to/results/#validation-results","title":"Validation Results","text":"<p>State machine validation returns structured results:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass ValidationResult:\n    valid: bool\n    reason: str = \"\"\n</code></pre> <p>Example: <pre><code>result = state_machine.validated_move_to_scale()\n\nif result.valid:\n    print(\"Move succeeded\")\nelse:\n    print(f\"Move failed: {result.reason}\")\n</code></pre></p>"},{"location":"how-to/results/#analyzing-results","title":"Analyzing Results","text":""},{"location":"how-to/results/#weight-accuracy-analysis","title":"Weight Accuracy Analysis","text":""},{"location":"how-to/results/#calculating-statistics","title":"Calculating Statistics","text":"<pre><code>import json\nimport statistics\n\ndef analyze_weight_accuracy(results_file):\n    \"\"\"\n    Analyze weight accuracy from results file.\n\n    Args:\n        results_file: Path to JSON file with dispense results\n    \"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    errors = []\n    percent_errors = []\n\n    for well_id, data in results.items():\n        if data['success']:\n            error = data['final_weight'] - data['target_weight']\n            percent_error = (error / data['target_weight']) * 100\n\n            errors.append(error)\n            percent_errors.append(abs(percent_error))\n\n    if not errors:\n        print(\"No successful operations to analyze\")\n        return\n\n    print(\"Weight Accuracy Analysis\")\n    print(\"=\" * 50)\n    print(f\"Total operations: {len(results)}\")\n    print(f\"Successful: {len(errors)}\")\n    print(f\"Failed: {len(results) - len(errors)}\")\n    print()\n    print(f\"Mean error: {statistics.mean(errors):.3f}g\")\n    print(f\"Std dev: {statistics.stdev(errors):.3f}g\")\n    print(f\"Min error: {min(errors):.3f}g\")\n    print(f\"Max error: {max(errors):.3f}g\")\n    print()\n    print(f\"Mean |% error|: {statistics.mean(percent_errors):.2f}%\")\n    print(f\"Max |% error|: {max(percent_errors):.2f}%\")\n\n# Usage\nanalyze_weight_accuracy(\"processing_results.json\")\n</code></pre> <p>Example output: <pre><code>Weight Accuracy Analysis\n==================================================\nTotal operations: 24\nSuccessful: 23\nFailed: 1\n\nMean error: 0.015g\nStd dev: 0.042g\nMin error: -0.08g\nMax error: 0.12g\n\nMean |% error|: 0.08%\nMax |% error|: 0.24%\n</code></pre></p>"},{"location":"how-to/results/#interpreting-accuracy-metrics","title":"Interpreting Accuracy Metrics","text":"Metric Good Acceptable Needs Attention Mean error &lt; 0.05g &lt; 0.1g &gt; 0.1g Std dev &lt; 0.05g &lt; 0.1g &gt; 0.1g Max error &lt; 0.1g &lt; 0.2g &gt; 0.2g Mean % error &lt; 0.1% &lt; 0.5% &gt; 0.5% <p>Target-Dependent</p> <p>These thresholds assume target weights around 50g. Adjust based on your application requirements.</p>"},{"location":"how-to/results/#success-rate-analysis","title":"Success Rate Analysis","text":"<pre><code>def analyze_success_rate(results_file):\n    \"\"\"Calculate success rate by well, time, or other factors.\"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    total = len(results)\n    successful = sum(1 for r in results.values() if r['success'])\n    failed = total - successful\n\n    success_rate = (successful / total) * 100\n\n    print(f\"Success Rate Analysis\")\n    print(f\"=\" * 50)\n    print(f\"Successful: {successful}/{total} ({success_rate:.1f}%)\")\n    print(f\"Failed: {failed}/{total} ({100-success_rate:.1f}%)\")\n\n    # Analyze failure reasons if available\n    failure_reasons = {}\n    for well_id, data in results.items():\n        if not data['success'] and data.get('error'):\n            reason = data['error']\n            failure_reasons[reason] = failure_reasons.get(reason, 0) + 1\n\n    if failure_reasons:\n        print(f\"\\nFailure Breakdown:\")\n        for reason, count in sorted(failure_reasons.items(), \n                                    key=lambda x: x[1], \n                                    reverse=True):\n            print(f\"  {reason}: {count}\")\n</code></pre>"},{"location":"how-to/results/#timing-analysis","title":"Timing Analysis","text":"<pre><code>def analyze_timing(results_file):\n    \"\"\"Analyze operation timing and identify bottlenecks.\"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    durations = [r['duration_seconds'] \n                 for r in results.values() \n                 if r['success']]\n\n    print(f\"Timing Analysis\")\n    print(f\"=\" * 50)\n    print(f\"Mean duration: {statistics.mean(durations):.1f}s\")\n    print(f\"Std dev: {statistics.stdev(durations):.1f}s\")\n    print(f\"Min: {min(durations):.1f}s\")\n    print(f\"Max: {max(durations):.1f}s\")\n    print(f\"Total time: {sum(durations)/60:.1f} minutes\")\n\n    # Estimate throughput\n    throughput = 3600 / statistics.mean(durations)  # operations per hour\n    print(f\"\\nEstimated throughput: {throughput:.1f} operations/hour\")\n</code></pre>"},{"location":"how-to/results/#visualization","title":"Visualization","text":""},{"location":"how-to/results/#plotting-weight-errors","title":"Plotting Weight Errors","text":"<pre><code>import matplotlib.pyplot as plt\nimport json\n\ndef plot_weight_errors(results_file, output_file='weight_errors.png'):\n    \"\"\"Plot weight errors for visual analysis.\"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    # Extract data\n    well_ids = []\n    errors = []\n\n    for well_id, data in sorted(results.items()):\n        if data['success']:\n            well_ids.append(well_id)\n            error = data['final_weight'] - data['target_weight']\n            errors.append(error)\n\n    # Create plot\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n\n    # Error by well\n    ax1.bar(well_ids, errors)\n    ax1.axhline(y=0, color='r', linestyle='--', alpha=0.5)\n    ax1.set_xlabel('Well ID')\n    ax1.set_ylabel('Error (g)')\n    ax1.set_title('Weight Error by Well')\n    ax1.grid(axis='y', alpha=0.3)\n\n    # Error distribution\n    ax2.hist(errors, bins=20, edgecolor='black')\n    ax2.axvline(x=0, color='r', linestyle='--', alpha=0.5)\n    ax2.set_xlabel('Error (g)')\n    ax2.set_ylabel('Frequency')\n    ax2.set_title('Error Distribution')\n    ax2.grid(axis='y', alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig(output_file, dpi=300)\n    print(f\"Plot saved to {output_file}\")\n\n# Usage\nplot_weight_errors(\"processing_results.json\")\n</code></pre>"},{"location":"how-to/results/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"how-to/results/#systematic-bias","title":"Systematic Bias","text":"<p>Symptom: Mean error is consistently positive or negative</p> <p>Example: All measurements 0.05g above target</p> <p>Causes: - Scale calibration drift - Tare weight incorrect - Environmental factors (drafts, vibration)</p> <p>Solutions: 1. Recalibrate scale 2. Update tare weights in configuration 3. Verify stable environment 4. Check for systematic loading issues</p>"},{"location":"how-to/results/#high-variability","title":"High Variability","text":"<p>Symptom: Large standard deviation in errors</p> <p>Example: Some wells at +0.15g, others at -0.10g</p> <p>Causes: - Inconsistent powder flow - Position-dependent issues - Mechanical play in system - Environmental variations</p> <p>Solutions: 1. Check trickler mechanism consistency 2. Verify all positions are accurately calibrated 3. Inspect mechanical components for wear 4. Improve environmental control</p>"},{"location":"how-to/results/#intermittent-failures","title":"Intermittent Failures","text":"<p>Symptom: Random operation failures</p> <p>Example: 95% success rate with no pattern</p> <p>Causes: - Communication timeouts - Sensor noise - Mechanical interference - Software race conditions</p> <p>Solutions: 1. Review error logs for patterns 2. Check network stability 3. Verify all connections secure 4. Add retry logic for transient failures</p>"},{"location":"how-to/results/#position-specific-issues","title":"Position-Specific Issues","text":"<p>Symptom: Failures or errors clustered in specific wells</p> <p>Example: Wells A1-A3 always fail, others succeed</p> <p>Causes: - Incorrect well position configuration - Physical obstacles at those locations - Tool/labware interference - State machine constraint violations</p> <p>Solutions: 1. Verify positions in configuration 2. Physically inspect problematic locations 3. Check state machine logs for validation errors 4. Manually test movements to those positions</p>"},{"location":"how-to/results/#generating-reports","title":"Generating Reports","text":""},{"location":"how-to/results/#automated-report-generation","title":"Automated Report Generation","text":"<pre><code>def generate_report(results_file, output_file='report.txt'):\n    \"\"\"Generate comprehensive analysis report.\"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    with open(output_file, 'w') as f:\n        f.write(\"Jubilee Powder Results Report\\n\")\n        f.write(\"=\" * 70 + \"\\n\\n\")\n\n        # Summary statistics\n        f.write(\"SUMMARY\\n\")\n        f.write(\"-\" * 70 + \"\\n\")\n        total = len(results)\n        successful = sum(1 for r in results.values() if r['success'])\n        f.write(f\"Total operations: {total}\\n\")\n        f.write(f\"Successful: {successful} ({successful/total*100:.1f}%)\\n\")\n        f.write(f\"Failed: {total-successful} ({(total-successful)/total*100:.1f}%)\\n\\n\")\n\n        # Weight accuracy\n        f.write(\"WEIGHT ACCURACY\\n\")\n        f.write(\"-\" * 70 + \"\\n\")\n        errors = [r['final_weight'] - r['target_weight'] \n                 for r in results.values() if r['success']]\n        if errors:\n            f.write(f\"Mean error: {statistics.mean(errors):.4f}g\\n\")\n            f.write(f\"Std deviation: {statistics.stdev(errors):.4f}g\\n\")\n            f.write(f\"Min error: {min(errors):.4f}g\\n\")\n            f.write(f\"Max error: {max(errors):.4f}g\\n\\n\")\n\n        # Timing\n        f.write(\"TIMING\\n\")\n        f.write(\"-\" * 70 + \"\\n\")\n        durations = [r['duration_seconds'] \n                    for r in results.values() if r['success']]\n        if durations:\n            f.write(f\"Mean duration: {statistics.mean(durations):.1f}s\\n\")\n            f.write(f\"Total time: {sum(durations)/60:.1f} minutes\\n\\n\")\n\n        # Detailed results\n        f.write(\"DETAILED RESULTS\\n\")\n        f.write(\"-\" * 70 + \"\\n\")\n        f.write(f\"{'Well':&lt;6} {'Target':&lt;8} {'Actual':&lt;8} {'Error':&lt;8} {'Status':&lt;10}\\n\")\n        f.write(\"-\" * 70 + \"\\n\")\n\n        for well_id in sorted(results.keys()):\n            data = results[well_id]\n            target = data['target_weight']\n            actual = data.get('final_weight', 0)\n            error = actual - target if data['success'] else 0\n            status = \"SUCCESS\" if data['success'] else \"FAILED\"\n\n            f.write(f\"{well_id:&lt;6} {target:&lt;8.2f} {actual:&lt;8.2f} \"\n                   f\"{error:&lt;8.3f} {status:&lt;10}\\n\")\n\n    print(f\"Report saved to {output_file}\")\n\n# Usage\ngenerate_report(\"processing_results.json\", \"analysis_report.txt\")\n</code></pre>"},{"location":"how-to/results/#export-formats","title":"Export Formats","text":""},{"location":"how-to/results/#csv-export","title":"CSV Export","text":"<pre><code>import csv\n\ndef export_to_csv(results_file, output_file='results.csv'):\n    \"\"\"Export results to CSV for analysis in Excel/other tools.\"\"\"\n    with open(results_file, 'r') as f:\n        results = json.load(f)\n\n    with open(output_file, 'w', newline='') as f:\n        writer = csv.writer(f)\n\n        # Header\n        writer.writerow(['Well ID', 'Success', 'Target Weight (g)', \n                        'Final Weight (g)', 'Error (g)', 'Percent Error (%)',\n                        'Duration (s)', 'Timestamp'])\n\n        # Data rows\n        for well_id in sorted(results.keys()):\n            data = results[well_id]\n            error = (data.get('final_weight', 0) - data['target_weight']) if data['success'] else None\n            percent_error = (error / data['target_weight'] * 100) if error is not None else None\n\n            writer.writerow([\n                well_id,\n                'Yes' if data['success'] else 'No',\n                data['target_weight'],\n                data.get('final_weight', ''),\n                error if error is not None else '',\n                f\"{percent_error:.2f}\" if percent_error is not None else '',\n                data.get('duration_seconds', ''),\n                data.get('timestamp', '')\n            ])\n\n    print(f\"CSV exported to {output_file}\")\n</code></pre>"},{"location":"how-to/results/#next-steps","title":"Next Steps","text":"<ul> <li>Optimize configuration based on results</li> <li>Re-run operations with adjusted parameters</li> <li>Review JubileeManager API for programmatic result handling</li> <li>Explore architecture concepts to understand system behavior</li> </ul>"},{"location":"how-to/run-new-data/","title":"How to Run Operations on New Data","text":"<p>This guide explains how to set up and run Jubilee operations with your own data and configurations.</p>"},{"location":"how-to/run-new-data/#overview","title":"Overview","text":"<p>Running operations on \"new data\" typically means:</p> <ol> <li>Setting up a new deck layout with your labware</li> <li>Defining new well positions and identifiers</li> <li>Running dispense operations on your custom configuration</li> <li>Processing results</li> </ol>"},{"location":"how-to/run-new-data/#prerequisites","title":"Prerequisites","text":"<ul> <li>[ ] Jubilee Automation installed and tested</li> <li>[ ] Hardware connected and functional</li> <li>[ ] Understanding of your deck layout requirements</li> </ul>"},{"location":"how-to/run-new-data/#step-1-plan-your-deck-layout","title":"Step 1: Plan Your Deck Layout","text":"<p>Before configuring anything, plan your physical deck layout:</p> <ol> <li>Identify all labware you'll use:</li> <li>Mold/well plates</li> <li>Piston dispensers</li> <li>Scale</li> <li> <p>Any other equipment</p> </li> <li> <p>Measure positions on the Jubilee deck:</p> </li> <li>Physical X, Y, Z coordinates</li> <li>Clearance heights for safe movement</li> <li> <p>Tool approach angles</p> </li> <li> <p>Assign identifiers to each well/position:</p> </li> <li>Use clear naming (e.g., \"A1\", \"B2\", \"row1_col1\")</li> <li>Be consistent with naming conventions</li> </ol>"},{"location":"how-to/run-new-data/#step-2-configure-deck-layout","title":"Step 2: Configure Deck Layout","text":"<p>Edit <code>jubilee_api_config/mold_labware.json</code> to define your labware:</p>"},{"location":"how-to/run-new-data/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"deck\": {\n    \"labware\": {\n      \"my_well_plate\": {\n        \"type\": \"well_plate\",\n        \"name\": \"My Custom Well Plate\",\n        \"rows\": 4,\n        \"columns\": 6,\n        \"well_spacing_x\": 20.0,\n        \"well_spacing_y\": 20.0,\n        \"origin\": {\n          \"x\": 50.0,\n          \"y\": 50.0,\n          \"z\": 10.0\n        },\n        \"wells\": {\n          \"A1\": {\n            \"position\": {\"x\": 50.0, \"y\": 50.0, \"z\": 10.0},\n            \"ready_pos\": \"mold_slot_A1\",\n            \"capacity_ml\": 10.0\n          },\n          \"A2\": {\n            \"position\": {\"x\": 70.0, \"y\": 50.0, \"z\": 10.0},\n            \"ready_pos\": \"mold_slot_A2\",\n            \"capacity_ml\": 10.0\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/run-new-data/#key-fields","title":"Key Fields","text":"<ul> <li><code>origin</code>: The (0,0) position of your well plate</li> <li><code>well_spacing_x/y</code>: Distance between wells in mm</li> <li><code>ready_pos</code>: The named position in the state machine config</li> </ul>"},{"location":"how-to/run-new-data/#step-3-configure-state-machine-positions","title":"Step 3: Configure State Machine Positions","text":"<p>Edit <code>jubilee_api_config/motion_platform_positions.json</code> to add your new positions:</p> <pre><code>{\n  \"positions\": {\n    \"mold_slot_A1\": {\n      \"coordinates\": {\n        \"x\": 50.0,\n        \"y\": 50.0,\n        \"z\": 100.0,\n        \"safe_z\": 150.0\n      },\n      \"description\": \"Ready position for well A1\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"empty\", \"mold\", \"mold_with_piston\"]\n    },\n    \"mold_slot_A2\": {\n      \"coordinates\": {\n        \"x\": 70.0,\n        \"y\": 50.0,\n        \"z\": 100.0,\n        \"safe_z\": 150.0\n      },\n      \"description\": \"Ready position for well A2\",\n      \"requires_tool\": \"manipulator\",\n      \"allowed_payloads\": [\"empty\", \"mold\", \"mold_with_piston\"]\n    }\n  },\n  \"transitions\": {\n    \"global_ready\": {\n      \"to\": [\"mold_slot_A1\", \"mold_slot_A2\", \"scale_ready\"]\n    },\n    \"mold_slot_A1\": {\n      \"to\": [\"global_ready\", \"scale_ready\"]\n    },\n    \"mold_slot_A2\": {\n      \"to\": [\"global_ready\", \"scale_ready\"]\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/run-new-data/#key-fields_1","title":"Key Fields","text":"<ul> <li><code>coordinates</code>: Physical position in mm</li> <li><code>safe_z</code>: Height for safe travel</li> <li><code>requires_tool</code>: Which tool must be active</li> <li><code>allowed_payloads</code>: Valid payload states</li> <li><code>transitions</code>: Which positions can be reached directly</li> </ul>"},{"location":"how-to/run-new-data/#step-4-create-a-processing-script","title":"Step 4: Create a Processing Script","text":"<p>Create a Python script to process your data:</p> <pre><code>from src.JubileeManager import JubileeManager\nimport json\nfrom pathlib import Path\n\ndef load_target_weights(data_file):\n    \"\"\"\n    Load target weights from your data file.\n\n    Args:\n        data_file: Path to JSON file with well IDs and target weights\n\n    Returns:\n        Dictionary mapping well IDs to target weights\n    \"\"\"\n    with open(data_file, 'r') as f:\n        return json.load(f)\n\ndef process_wells(manager, target_weights):\n    \"\"\"\n    Process all wells with their target weights.\n\n    Args:\n        manager: Connected JubileeManager instance\n        target_weights: Dict of {well_id: target_weight}\n\n    Returns:\n        Dictionary with results for each well\n    \"\"\"\n    results = {}\n\n    for well_id, target_weight in target_weights.items():\n        print(f\"Processing {well_id} with target weight {target_weight}g...\")\n\n        success = manager.dispense_to_well(\n            well_id=well_id,\n            target_weight=target_weight\n        )\n\n        # Get final weight for verification\n        if success:\n            # Move back to scale to verify (optional)\n            final_weight = manager.get_weight_stable()\n        else:\n            final_weight = None\n\n        results[well_id] = {\n            \"success\": success,\n            \"target_weight\": target_weight,\n            \"final_weight\": final_weight,\n            \"error\": None if success else \"Dispense failed\"\n        }\n\n        print(f\"  Result: {'SUCCESS' if success else 'FAILED'}\")\n\n    return results\n\ndef save_results(results, output_file):\n    \"\"\"Save processing results to JSON file.\"\"\"\n    with open(output_file, 'w') as f:\n        json.dump(results, f, indent=2)\n    print(f\"Results saved to {output_file}\")\n\ndef main():\n    # Configuration\n    DATA_FILE = \"my_target_weights.json\"  # Your input data\n    OUTPUT_FILE = \"processing_results.json\"  # Results output\n    JUBILEE_IP = \"192.168.1.100\"\n\n    # Load target weights\n    target_weights = load_target_weights(DATA_FILE)\n    print(f\"Loaded {len(target_weights)} wells to process\")\n\n    # Create and connect manager\n    manager = JubileeManager(\n        num_piston_dispensers=2,\n        num_pistons_per_dispenser=10\n    )\n\n    if not manager.connect(machine_address=JUBILEE_IP):\n        print(\"Failed to connect to Jubilee!\")\n        return\n\n    try:\n        # Process all wells\n        results = process_wells(manager, target_weights)\n\n        # Save results\n        save_results(results, OUTPUT_FILE)\n\n        # Print summary\n        successful = sum(1 for r in results.values() if r[\"success\"])\n        print(f\"\\nProcessing complete:\")\n        print(f\"  Successful: {successful}/{len(results)}\")\n        print(f\"  Failed: {len(results) - successful}/{len(results)}\")\n\n    finally:\n        manager.disconnect()\n        print(\"Disconnected from hardware\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/run-new-data/#step-5-prepare-your-input-data","title":"Step 5: Prepare Your Input Data","text":"<p>Create a JSON file with your target weights (<code>my_target_weights.json</code>):</p> <pre><code>{\n  \"A1\": 50.5,\n  \"A2\": 45.0,\n  \"A3\": 52.3,\n  \"B1\": 48.7,\n  \"B2\": 51.2\n}\n</code></pre>"},{"location":"how-to/run-new-data/#step-6-run-your-script","title":"Step 6: Run Your Script","text":"<ol> <li> <p>Test with one well first: <pre><code>target_weights = {\"A1\": 50.0}  # Start with just one\n</code></pre></p> </li> <li> <p>Monitor the first run:</p> </li> <li>Watch the Jubilee physically</li> <li>Be ready to emergency stop if needed</li> <li> <p>Verify positions are correct</p> </li> <li> <p>Run full batch after successful test: <pre><code>python process_my_data.py\n</code></pre></p> </li> </ol>"},{"location":"how-to/run-new-data/#step-7-verify-results","title":"Step 7: Verify Results","text":"<p>Check the output file (<code>processing_results.json</code>):</p> <pre><code>{\n  \"A1\": {\n    \"success\": true,\n    \"target_weight\": 50.5,\n    \"final_weight\": 50.48,\n    \"error\": null\n  },\n  \"A2\": {\n    \"success\": true,\n    \"target_weight\": 45.0,\n    \"final_weight\": 45.02,\n    \"error\": null\n  }\n}\n</code></pre>"},{"location":"how-to/run-new-data/#expected-output","title":"Expected Output","text":"<p>During a successful run, you should see:</p> <pre><code>Loaded 5 wells to process\nConnected successfully!\nProcessing A1 with target weight 50.5g...\n  Result: SUCCESS\nProcessing A2 with target weight 45.0g...\n  Result: SUCCESS\n...\nResults saved to processing_results.json\n\nProcessing complete:\n  Successful: 5/5\n  Failed: 0/5\nDisconnected from hardware\n</code></pre>"},{"location":"how-to/run-new-data/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/run-new-data/#well-id-not-found","title":"Well ID Not Found","text":"<p>Symptom: Error \"Well ID 'X1' not found\"</p> <p>Solution: - Check that the well ID exists in <code>mold_labware.json</code> - Verify the well ID spelling/case matches exactly - Ensure the labware is loaded in the configuration</p>"},{"location":"how-to/run-new-data/#position-validation-failed","title":"Position Validation Failed","text":"<p>Symptom: \"Move to mold slot failed: validation error\"</p> <p>Solution: - Check that the position is defined in <code>motion_platform_positions.json</code> - Verify the <code>ready_pos</code> field in the well configuration matches the position name - Ensure transitions are defined from current position to target position</p>"},{"location":"how-to/run-new-data/#incorrect-physical-position","title":"Incorrect Physical Position","text":"<p>Symptom: Jubilee moves to wrong location</p> <p>Solution: - Verify coordinates in configuration are correct - Check that you're using the right coordinate system (absolute vs relative) - Home the Jubilee before starting - Use the Duet Web Control to manually verify positions</p>"},{"location":"how-to/run-new-data/#dispense-fails","title":"Dispense Fails","text":"<p>Symptom: <code>dispense_to_well()</code> returns False</p> <p>Solution: - Check that pistons are available in dispenser - Verify scale is connected and responding - Ensure trickler/powder source is configured - Check logs for specific error messages</p>"},{"location":"how-to/run-new-data/#tips","title":"Tips","text":"<p>Start Small</p> <p>Always test with a single well before running large batches.</p> <p>Backup Configurations</p> <p>Keep backup copies of working configurations before making changes.</p> <p>Use Relative Positions</p> <p>Define well positions relative to a reference point for easier reconfiguration.</p> <p>Verify Physically</p> <p>Always verify that configured positions match physical reality before running automated operations.</p>"},{"location":"how-to/run-new-data/#next-steps","title":"Next Steps","text":"<ul> <li>Configure advanced parameters</li> <li>Interpret and analyze results</li> <li>Use the Web UI for monitoring</li> </ul>"},{"location":"how-to/web-ui/","title":"Using the Jubilee Web UI","text":"<p>This guide explains how to use the Jubilee's web interface and the custom GUI application for controlling and monitoring the system.</p>"},{"location":"how-to/web-ui/#overview","title":"Overview","text":"<p>There are two web interfaces available:</p> <ol> <li>Duet Web Control (DWC): The built-in Jubilee controller interface</li> <li>Jubilee GUI: Custom Python GUI application for high-level operations</li> </ol>"},{"location":"how-to/web-ui/#duet-web-control-dwc","title":"Duet Web Control (DWC)","text":""},{"location":"how-to/web-ui/#accessing-dwc","title":"Accessing DWC","text":"<ol> <li>Open a web browser</li> <li>Navigate to your Jubilee's IP address: <code>http://192.168.1.100</code> (use your configured IP)</li> <li>The Duet Web Control interface will load</li> </ol>"},{"location":"how-to/web-ui/#dwc-interface-overview","title":"DWC Interface Overview","text":"<p>The DWC provides low-level control of the Jubilee:</p> <ul> <li>Machine Control: Manual jog controls for all axes</li> <li>Console: Send G-code commands directly</li> <li>Status: View current positions, temperatures, and states</li> <li>Files: Upload and manage G-code files</li> <li>Macros: Run predefined macro files</li> </ul>"},{"location":"how-to/web-ui/#common-dwc-tasks","title":"Common DWC Tasks","text":""},{"location":"how-to/web-ui/#manual-movement","title":"Manual Movement","text":"<ol> <li>Click the Machine Control tab</li> <li>Select the axis to move (X, Y, Z, U, V)</li> <li>Choose movement distance (0.1mm, 1mm, 10mm, 100mm)</li> <li>Click directional buttons to move</li> </ol> <p>Safety</p> <p>Manual movements in DWC bypass the state machine validation. Be careful not to cause collisions.</p>"},{"location":"how-to/web-ui/#homing-axes","title":"Homing Axes","text":"<ol> <li>In Machine Control, find the \"Home\" section</li> <li>Click Home All to home all axes, or</li> <li>Click individual axis buttons (Home X, Home Y, etc.)</li> </ol>"},{"location":"how-to/web-ui/#running-macros","title":"Running Macros","text":"<ol> <li>Click the Macros tab (or Job tab in some versions)</li> <li>Browse available macros</li> <li>Click a macro name to execute it</li> </ol> <p>Useful macros: - <code>homeall.g</code>: Home all axes - <code>tool_lock.g</code>: Lock the current tool - <code>tool_unlock.g</code>: Unlock the current tool</p>"},{"location":"how-to/web-ui/#sending-g-code-commands","title":"Sending G-code Commands","text":"<ol> <li>Click the Console tab</li> <li>Type G-code in the input box at the bottom</li> <li>Press Enter to send</li> </ol> <p>Common G-code commands: <pre><code>G28          ; Home all axes\nG90          ; Absolute positioning\nG91          ; Relative positioning\nG1 X100 Y50 F5000  ; Move to X=100, Y=50 at 5000 mm/min\nM114         ; Report current position\nM999         ; Reset controller after emergency stop\n</code></pre></p>"},{"location":"how-to/web-ui/#monitoring-status","title":"Monitoring Status","text":"<p>The Status section shows: - Current X, Y, Z, U, V positions - Active tool (T0, T1, etc.) - Machine state (idle, processing, paused) - Temperature readings (if applicable)</p>"},{"location":"how-to/web-ui/#when-to-use-dwc","title":"When to Use DWC","text":"<p>Use Duet Web Control for: - \u2705 Manual troubleshooting - \u2705 Testing individual movements - \u2705 Verifying positions - \u2705 Emergency control - \u2705 Low-level debugging</p> <p>Do not use for: - \u274c Automated operations (use Python API instead) - \u274c Complex multi-step procedures (use JubileeManager) - \u274c Production workflows (use scripted automation)</p>"},{"location":"how-to/web-ui/#jubilee-gui-application","title":"Jubilee GUI Application","text":""},{"location":"how-to/web-ui/#starting-the-gui","title":"Starting the GUI","text":"<p>Option 1: Using the launch script <pre><code>cd src/\n./start_gui.sh\n</code></pre></p> <p>Option 2: Running directly <pre><code>cd src/\npython jubilee_gui.py\n</code></pre></p> <p>Option 3: From GUI directory <pre><code>cd gui/\npython jubilee_gui.py\n</code></pre></p>"},{"location":"how-to/web-ui/#gui-interface-overview","title":"GUI Interface Overview","text":"<p>The custom GUI provides high-level control through the JubileeManager API.</p>"},{"location":"how-to/web-ui/#main-components","title":"Main Components","text":"<ol> <li>Connection Panel</li> <li>IP address input</li> <li>Scale port selection</li> <li>Connect/Disconnect button</li> <li> <p>Connection status indicator</p> </li> <li> <p>Control Panel</p> </li> <li>Quick action buttons</li> <li>Dispense operation controls</li> <li> <p>Weight display</p> </li> <li> <p>Status Display</p> </li> <li>Current position</li> <li>Active tool</li> <li>Payload state</li> <li> <p>Scale reading</p> </li> <li> <p>Log/Console</p> </li> <li>Operation feedback</li> <li>Error messages</li> <li>Status updates</li> </ol>"},{"location":"how-to/web-ui/#common-gui-tasks","title":"Common GUI Tasks","text":""},{"location":"how-to/web-ui/#connecting-to-hardware","title":"Connecting to Hardware","text":"<ol> <li>Enter Jubilee IP address (e.g., <code>192.168.1.100</code>)</li> <li>Select scale port from dropdown (e.g., <code>/dev/ttyUSB0</code>)</li> <li>Click Connect button</li> <li>Wait for initialization (homing, tool pickup, etc.)</li> <li>Status indicator turns green when ready</li> </ol>"},{"location":"how-to/web-ui/#reading-scale-weight","title":"Reading Scale Weight","text":"<ol> <li>Ensure connection is established</li> <li>The weight display updates automatically</li> <li>For stable reading, wait for indicator to show stable</li> <li>Click Tare button to zero the scale</li> </ol>"},{"location":"how-to/web-ui/#dispensing-to-a-well","title":"Dispensing to a Well","text":"<ol> <li>Select target well from dropdown (e.g., \"A1\")</li> <li>Enter target weight in grams</li> <li>Click Dispense button</li> <li>Monitor progress in status display</li> <li>Check results when operation completes</li> </ol>"},{"location":"how-to/web-ui/#manual-positioning","title":"Manual Positioning","text":"<ol> <li>Select target position from dropdown</li> <li>Click Move To button</li> <li>System validates and executes movement</li> <li>Status updates when movement completes</li> </ol>"},{"location":"how-to/web-ui/#emergency-stop","title":"Emergency Stop","text":"<ol> <li>Click the E-STOP button in the GUI, or</li> <li>Press the physical emergency stop on the Jubilee</li> <li>System halts all movement immediately</li> <li>Reconnect and rehome before continuing</li> </ol>"},{"location":"how-to/web-ui/#gui-configuration","title":"GUI Configuration","text":"<p>The GUI reads settings from the same configuration files as the Python API:</p> <ul> <li><code>jubilee_api_config/system_config.json</code></li> <li><code>jubilee_api_config/motion_platform_positions.json</code></li> <li><code>jubilee_api_config/mold_labware.json</code></li> </ul> <p>To customize the GUI:</p> <ol> <li>Edit configuration files as needed</li> <li>Restart the GUI application</li> <li>Changes take effect on next connection</li> </ol>"},{"location":"how-to/web-ui/#web-ui-best-practices","title":"Web UI Best Practices","text":""},{"location":"how-to/web-ui/#safety","title":"Safety","text":"<p>Always Monitor First Run</p> <p>Watch the Jubilee physically during the first run of any operation. Keep your hand near the emergency stop.</p>"},{"location":"how-to/web-ui/#dwc-best-practices","title":"DWC Best Practices","text":"<ol> <li>Use relative movements when testing: <code>G91</code> then <code>G1 X10</code> to move 10mm in X</li> <li>Start with small movements: Test with 1mm increments before larger moves</li> <li>Check current position before moving: <code>M114</code> shows current coordinates</li> <li>Home after errors: If something goes wrong, home all axes before continuing</li> </ol>"},{"location":"how-to/web-ui/#gui-best-practices","title":"GUI Best Practices","text":"<ol> <li>Test connectivity before starting operations</li> <li>Verify well positions using manual positioning first</li> <li>Start with small batches: Test 1-2 wells before running large batches</li> <li>Monitor logs: Watch the log panel for errors or warnings</li> <li>Save configurations: Export successful configurations for backup</li> </ol>"},{"location":"how-to/web-ui/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/web-ui/#cannot-access-dwc","title":"Cannot Access DWC","text":"<p>Symptoms: - Browser shows \"Cannot connect\" or timeout - Address not reachable</p> <p>Solutions: 1. Verify Jubilee is powered on 2. Check network connection 3. Ping the IP address: <code>ping 192.168.1.100</code> 4. Try accessing from different computer 5. Check firewall settings 6. Verify IP address is correct (check <code>system_config.json</code>)</p>"},{"location":"how-to/web-ui/#gui-wont-start","title":"GUI Won't Start","text":"<p>Symptoms: - Error when running <code>jubilee_gui.py</code> - Import errors or missing modules</p> <p>Solutions: 1. Ensure virtual environment is activated 2. Install dependencies: <code>pip install -r requirements.txt</code> 3. For GUI-specific deps: <code>pip install -r gui/requirements.txt</code> 4. Check Python version (3.8+ required)</p>"},{"location":"how-to/web-ui/#connection-fails-in-gui","title":"Connection Fails in GUI","text":"<p>Symptoms: - \"Failed to connect\" message - Connection button stays red</p> <p>Solutions: 1. Verify IP address is correct 2. Check scale is connected (try <code>ls /dev/ttyUSB*</code>) 3. Ensure no other program is using the scale port 4. Check that Jubilee is responsive in DWC 5. Review error messages in log panel</p>"},{"location":"how-to/web-ui/#movement-commands-dont-work","title":"Movement Commands Don't Work","text":"<p>Symptoms: - Buttons don't respond - \"Movement failed\" errors</p> <p>Solutions: 1. Ensure system is connected 2. Check that homing completed successfully 3. Verify tool is picked up if required 4. Check logs for validation errors 5. Ensure target positions are defined in config</p>"},{"location":"how-to/web-ui/#scale-not-updating","title":"Scale Not Updating","text":"<p>Symptoms: - Weight display shows zero or stale value - \"Scale not connected\" warning</p> <p>Solutions: 1. Check USB connection to scale 2. Verify correct port selected 3. Try different USB port 4. Check scale has power 5. Test scale connection manually: <code>python -c \"from src.Scale import Scale; s = Scale(); s.connect(); print(s.get_weight())\"</code></p>"},{"location":"how-to/web-ui/#advanced-features","title":"Advanced Features","text":""},{"location":"how-to/web-ui/#creating-custom-macros-dwc","title":"Creating Custom Macros (DWC)","text":"<p>You can create custom G-code macros for repetitive tasks:</p> <ol> <li>In DWC, go to System tab</li> <li>Navigate to <code>/sys/macros/</code></li> <li>Create new file (e.g., <code>my_custom_move.g</code>)</li> <li>Write G-code:</li> </ol> <pre><code>; My Custom Move Macro\nG28                      ; Home all\nG1 X100 Y100 Z50 F5000  ; Move to position\nM400                     ; Wait for moves to complete\nM291 P\"Movement complete\" S1  ; Show message\n</code></pre> <ol> <li>Save file</li> <li>Macro appears in Macros list</li> </ol>"},{"location":"how-to/web-ui/#monitoring-from-multiple-devices","title":"Monitoring from Multiple Devices","text":"<p>You can access DWC from multiple browsers simultaneously:</p> <ul> <li>One person monitors in lab</li> <li>Another controls remotely</li> <li>All see the same state</li> </ul> <p>Coordination Required</p> <p>If multiple people send commands, they may conflict. Coordinate who is in control.</p>"},{"location":"how-to/web-ui/#integrating-with-external-tools","title":"Integrating with External Tools","text":"<p>The GUI and API can be controlled programmatically:</p> <pre><code># External control example\nfrom src.JubileeManager import JubileeManager\n\n# Create manager (could be controlled by another application)\nmanager = JubileeManager()\nif manager.connect():\n    # Perform operations\n    pass\n</code></pre>"},{"location":"how-to/web-ui/#next-steps","title":"Next Steps","text":"<ul> <li>Configure your system for custom operations</li> <li>Run automated operations using Python scripts</li> <li>Interpret results from dispense operations</li> <li>Review JubileeManager API for programmatic control</li> </ul>"}]}